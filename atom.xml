<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千里一日还先生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-02T05:52:57.858Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Turbolento</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tornado.web.RequestHandler对象详解</title>
    <link href="http://yoursite.com/2018/08/02/tornado-web-RequestHandler%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/02/tornado-web-RequestHandler对象详解/</id>
    <published>2018-08-02T02:01:29.000Z</published>
    <updated>2018-08-02T05:52:57.858Z</updated>
    
    <content type="html"><![CDATA[<p>RequestHandler是tornado处理http请求的基类。对于一个http请求，使用此类获取请求的内容，并定制其响应内容。下面总结一下该类所包含的方法或变量。</p><h3 id="1、-self-request对象包含请求中的所有信息"><a href="#1、-self-request对象包含请求中的所有信息" class="headerlink" title="1、 self.request对象包含请求中的所有信息"></a>1、 self.request对象包含请求中的所有信息</h3><p>&emsp;&emsp;使用dir(self.request)打印出来的内容有：[‘__class__‘, ‘__delattr__‘, ‘__dict__‘, ‘__doc__‘, ‘__format__‘, ‘__getattribute__‘, ‘__hash__‘, ‘__init__‘, ‘__module__‘, ‘__new__‘, ‘__reduce__‘, ‘__reduce<em>ex\</em>_‘, ‘__repr__‘, ‘__setattr__‘, ‘__sizeof__‘, ‘__str__‘, ‘__subclasshook__‘, ‘__weakref__‘, ‘_finish_time’, ‘_parse_body’, ‘_start_time’, ‘arguments’, ‘body’, ‘body_arguments’, ‘connection’, ‘cookies’, ‘files’, ‘finish’, ‘full_url’, ‘get_ssl_certificate’, ‘headers’, ‘host’, ‘host_name’, ‘method’, ‘path’, ‘protocol’, ‘query’, ‘query_arguments’, ‘remote_ip’, ‘request_time’, ‘server_connection’, ‘supports_http_1_1’, ‘uri’, ‘version’, ‘write’]  </p><p>实际请求如下：</p><pre><code>function post() {        url = &quot;http://10.126.1.209:8008/page?x=123&amp;y=222&amp;x=234&quot;        var htmlobj=$.ajax({url:url,async:false,data:&quot;abc\nxyx&quot;,type:&quot;POST&quot;,headers:{&quot;user&quot;:&quot;admin&quot;}});        $(&quot;#response&quot;).html(htmlobj.responseText);    }</code></pre><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">说明</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">__class__</td><td style="text-align:left">具体的类名</td><td style="text-align:left">&lt;class ‘tornado.httputil.HTTPServerRequest’&gt;</td></tr><tr><td style="text-align:left">__dict__</td><td style="text-align:left">self.request对象所包含的所有非继承属性</td><td style="text-align:left">{‘body’:’a=b&amp;aa=bb’, <br>‘files’: {}, <br>‘protocol’: ‘http’,<br> ‘connection’: &lt;tornado.http1connection.HTTP1Connection object at 0x0387D330&gt;, <br>‘body_arguments’: {‘a’: [‘b’], ‘aa’: [‘bb’]}, <br>‘uri’: ‘/page’, <br>‘query_arguments’: {}, <br>‘_start_time’: 1533177225.76, <br>‘headers’: &lt;tornado.httputil.HTTPHeaders object at 0x0387D470&gt;,<br> ‘host’: ‘10.126.1.209:8008’,<br> ‘version’: ‘HTTP/1.1’,<br> ‘server_connection’: &lt;tornado.http1connection.HTTP1ServerConnection object at 0x0387D2B0&gt;, <br>‘host_name’: ‘10.126.1.209’, <br>‘_finish_time’: None, <br>‘query’: ‘’, <br>‘arguments’: {‘a’: [‘b’], ‘aa’: [‘bb’]}, <br>‘path’: ‘/page’, <br>‘method’: ‘POST’, <br>‘remote_ip’: ‘10.126.1.209’}</td></tr><tr><td style="text-align:left">_start_time</td><td style="text-align:left">请求开始时间</td><td style="text-align:left">1533177225.76</td></tr><tr><td style="text-align:left">arguments</td><td style="text-align:left">所有请求参数，包含url中的query部分，以及请求Body中的参数。（说明：query参数相同key可以保存多个value，body中的参数同名只会保存最后一个值）。<br>当请求Body为字符串的时候，将字符串作为arguments的key，value为空值</td><td style="text-align:left">a） {‘y’: [‘222’], ‘x’: [‘123’, ‘234’], ‘aa’: [‘bb’], ‘a’: [‘c’]}<br>b） 请求data变为”abc”时，{‘y’: [‘222’], ‘x’: [‘123’, ‘234’], ‘abc’: [‘’]}</td></tr><tr><td style="text-align:left">body</td><td style="text-align:left">字符串类型，请求Body内容，urlencode编码后的字符串</td><td style="text-align:left">a=c&amp;aa=bb或者abc</td></tr><tr><td style="text-align:left">body_arguments</td><td style="text-align:left">同arguments，只包含body中的参数</td><td style="text-align:left">{‘a’: [‘c’], ‘aa’: [‘bb’]}或者{‘abc’: [‘’]}</td></tr><tr><td style="text-align:left">cookies</td><td style="text-align:left">获取请求cookies字符串内容</td><td style="text-align:left">_xsrf=2&#124;b362be79&#124;83193f43f7fb09b14cbd70ef9bfc1748&#124;1532330344; user=”2&#124;1:0&#124;10:1533116808&#124;4:user&#124;8:YWRtaW4=&#124;ac6a2f9f3df2c67e903490af706fe7881208abb30c4108b87779dd8fffdbe349”</td></tr><tr><td style="text-align:left">files</td><td style="text-align:left">传输的文件</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">headers</td><td style="text-align:left">请求头</td><td style="text-align:left">Origin: <a href="http://localhost:63342" target="_blank" rel="noopener">http://localhost:63342</a><br>Content-Length: 3<br>Accept-Language: zh-CN,zh;q=0.9<br>Accept-Encoding: gzip, deflate<br>Connection: keep-alive<br>Accept: <em>/</em><br>User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36<br>Host: 10.126.1.209:8008<br>Referer: <a href="http://localhost:63342/consul/test.html?_ijt=7qq0e9dtrj0j7ikqsgee0qu9gq" target="_blank" rel="noopener">http://localhost:63342/consul/test.html?_ijt=7qq0e9dtrj0j7ikqsgee0qu9gq</a><br>Content-Type: application/x-www-form-urlencoded; charset=UTF-8</td></tr><tr><td style="text-align:left">host</td><td style="text-align:left">请求的主机</td><td style="text-align:left">10.126.1.209:8008</td></tr><tr><td style="text-align:left">host_name</td><td style="text-align:left">主机名</td><td style="text-align:left">10.126.1.209</td></tr><tr><td style="text-align:left">method</td><td style="text-align:left">请求的方法</td><td style="text-align:left">POST/GET</td></tr><tr><td style="text-align:left">path</td><td style="text-align:left">请求的资源路径，不带query参数</td><td style="text-align:left">/page</td></tr><tr><td style="text-align:left">protocol</td><td style="text-align:left">协议类型</td><td style="text-align:left">http/https</td></tr><tr><td style="text-align:left">query</td><td style="text-align:left">请求地址中query部分的参数</td><td style="text-align:left">x=123&amp;y=222&amp;x=234</td></tr><tr><td style="text-align:left">query_arguments</td><td style="text-align:left">类似于arguments，但是只包含query部分</td><td style="text-align:left">{‘y’: [‘222’], ‘x’: [‘123’, ‘234’]}</td></tr><tr><td style="text-align:left">remote_ip</td><td style="text-align:left">请求主机地址</td><td style="text-align:left">10.126.1.209</td></tr><tr><td style="text-align:left">version</td><td style="text-align:left">协议版本</td><td style="text-align:left">HTTP/1.1</td></tr></tbody></table><h3 id="2、-RequestHandler响应设置的一些方法"><a href="#2、-RequestHandler响应设置的一些方法" class="headerlink" title="2、 RequestHandler响应设置的一些方法"></a>2、 RequestHandler响应设置的一些方法</h3><h4 id="2-1-self-set-header-name-value-设置响应头"><a href="#2-1-self-set-header-name-value-设置响应头" class="headerlink" title="2.1  self.set_header(name,value)设置响应头"></a>2.1  <code>self.set_header(name,value)</code>设置响应头</h4><p><code>add_header(name,value)</code>也可设置响应头</p><h4 id="2-2-self-get-argument-name-default-获取请求参数"><a href="#2-2-self-get-argument-name-default-获取请求参数" class="headerlink" title="2.2  self.get_argument(name,[default])获取请求参数"></a>2.2  <code>self.get_argument(name,[default])</code>获取请求参数</h4><p>如果有多个值只获取最后一个值</p><h4 id="2-3-self-write-chunk-将内容写进response-body中去"><a href="#2-3-self-write-chunk-将内容写进response-body中去" class="headerlink" title="2.3  self.write(chunk)将内容写进response body中去"></a>2.3  <code>self.write(chunk)</code>将内容写进response body中去</h4><h4 id="2-4-self-finish-chunk-关闭连接"><a href="#2-4-self-finish-chunk-关闭连接" class="headerlink" title="2.4  self.finish([chunk])关闭连接"></a>2.4  <code>self.finish([chunk])</code>关闭连接</h4><h4 id="2-5-self-set-secure-cookie-name-value-expires-days-设置安全cookie"><a href="#2-5-self-set-secure-cookie-name-value-expires-days-设置安全cookie" class="headerlink" title="2.5  self.set_secure_cookie(name,value,expires_days,...)设置安全cookie"></a>2.5  <code>self.set_secure_cookie(name,value,expires_days,...)</code>设置安全cookie</h4><h4 id="2-6-self-write-error-status-code-kwargs-返回错误响应内容"><a href="#2-6-self-write-error-status-code-kwargs-返回错误响应内容" class="headerlink" title="2.6  self.write_error(status_code,kwargs)返回错误响应内容"></a>2.6  <code>self.write_error(status_code,kwargs)</code>返回错误响应内容</h4><h4 id="2-7-self-set-status-status-code-reason-返回指定响应码和响应描述"><a href="#2-7-self-set-status-status-code-reason-返回指定响应码和响应描述" class="headerlink" title="2.7  self.set_status(status_code,reason)返回指定响应码和响应描述"></a>2.7  <code>self.set_status(status_code,reason)</code>返回指定响应码和响应描述</h4><h4 id="2-8-self-clear-cookie-name-path-domain-清除指定cookie"><a href="#2-8-self-clear-cookie-name-path-domain-清除指定cookie" class="headerlink" title="2.8  self.clear_cookie(name,path,domain)清除指定cookie"></a>2.8  <code>self.clear_cookie(name,path,domain)</code>清除指定cookie</h4><h4 id="2-9-self-redirect-url-permanent-status-重定向到指定url"><a href="#2-9-self-redirect-url-permanent-status-重定向到指定url" class="headerlink" title="2.9  self.redirect(url,permanent,status)重定向到指定url"></a>2.9  <code>self.redirect(url,permanent,status)</code>重定向到指定url</h4><h4 id="2-10-self-get-secure-cookie-name-value-获取安全cookie"><a href="#2-10-self-get-secure-cookie-name-value-获取安全cookie" class="headerlink" title="2.10  self.get_secure_cookie(name,value,...)获取安全cookie"></a>2.10  <code>self.get_secure_cookie(name,value,...)</code>获取安全cookie</h4><h4 id="2-11-self-on-finish-响应发送到客户端，关闭连接后调用"><a href="#2-11-self-on-finish-响应发送到客户端，关闭连接后调用" class="headerlink" title="2.11  self.on_finish()响应发送到客户端，关闭连接后调用"></a>2.11  <code>self.on_finish()</code>响应发送到客户端，关闭连接后调用</h4><h4 id="2-12-self-render-templateName-kwargs-渲染模板并作为响应内容"><a href="#2-12-self-render-templateName-kwargs-渲染模板并作为响应内容" class="headerlink" title="2.12  self.render(templateName,kwargs)渲染模板并作为响应内容"></a>2.12  <code>self.render(templateName,kwargs)</code>渲染模板并作为响应内容</h4><style>table th:first-of-type {    width: 150px;}table th:nth-child(2){    width:200px;}table td{    word-break:break-all;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RequestHandler是tornado处理http请求的基类。对于一个http请求，使用此类获取请求的内容，并定制其响应内容。下面总结一下该类所包含的方法或变量。&lt;/p&gt;
&lt;h3 id=&quot;1、-self-request对象包含请求中的所有信息&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="RequestHandler" scheme="http://yoursite.com/tags/RequestHandler/"/>
    
  </entry>
  
  <entry>
    <title>解决SQLAlchemy间隔长时间重连，提示MySQL server has gone away</title>
    <link href="http://yoursite.com/2018/08/01/%E8%A7%A3%E5%86%B3SQLAlchemy%E9%97%B4%E9%9A%94%E9%95%BF%E6%97%B6%E9%97%B4%E9%87%8D%E8%BF%9E%EF%BC%8C%E6%8F%90%E7%A4%BAMySQL-server-has-gone-away/"/>
    <id>http://yoursite.com/2018/08/01/解决SQLAlchemy间隔长时间重连，提示MySQL-server-has-gone-away/</id>
    <published>2018-08-01T02:33:43.000Z</published>
    <updated>2018-08-01T02:55:58.556Z</updated>
    
    <content type="html"><![CDATA[<p>在构建tornado应用，采用SQLAlchemy作为ORM是一个比较不错的选择。使用SQLAlchemy，一般第一步需要用create_engine创建engine，但在一段时间不使用engine的时候，下次连接时会提示[2006]MySQL server has gone away的错误！如下图：<br><img src="/upload/sqlalchemy_error1.png" alt="imgName"></p><p>解决方法：  </p><pre><code>from sqlalchemy import create_engine, eventfrom sqlalchemy.exc import DisconnectionErrordef checkout_listener(dbapi_con, con_record, con_proxy):    try:        try:            dbapi_con.ping(False)        except TypeError:            dbapi_con.ping()    except dbapi_con.OperationalError as exc:        if exc.args[0] in (2006, 2013, 2014, 2045, 2055):            raise DisconnectionError()        else:            raisedb_engine = create_engine(DATABASE_CONNECTION_INFO,                          pool_size=100,                          pool_recycle=3600)event.listen(db_engine, &apos;checkout&apos;, checkout_listener)</code></pre><blockquote><p>参考文档：<a href="http://discorporate.us/jek/talks/SQLAlchemy-EuroPython2010.pdf" target="_blank" rel="noopener">http://discorporate.us/jek/talks/SQLAlchemy-EuroPython2010.pdf</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在构建tornado应用，采用SQLAlchemy作为ORM是一个比较不错的选择。使用SQLAlchemy，一般第一步需要用create_engine创建engine，但在一段时间不使用engine的时候，下次连接时会提示[2006]MySQL server has gon
      
    
    </summary>
    
      <category term="SQLAlchemy" scheme="http://yoursite.com/categories/SQLAlchemy/"/>
    
      <category term="问题记录" scheme="http://yoursite.com/categories/SQLAlchemy/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="ORM" scheme="http://yoursite.com/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>利用libsvm识别图形验证码</title>
    <link href="http://yoursite.com/2018/07/23/%E5%88%A9%E7%94%A8libsvm%E8%AF%86%E5%88%AB%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://yoursite.com/2018/07/23/利用libsvm识别图形验证码/</id>
    <published>2018-07-23T01:23:51.000Z</published>
    <updated>2018-07-23T02:53:59.544Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;IBSVM软件包是台湾大学林智仁(Chih-Jen Lin)博士等用C++实现的LIBSVM库，可以说是使用最方便的SVM训练工具[71]。可以解决分类问题(包括C-SVC、n-SVC)、回归问题(包括e-SVR、n-SVR)以及分布估计(one-class-SVM )等问题，提供了线性、多项式、径向基和S形函数四种常用的核函数供选择，可以有效地解决多类问题、交叉验证选择参数、对不平衡样本加权、多类问题的概率估计等。  </p><pre><code># coding:utf-8import urllib.requestimport cairosvg, cv2from svmutil import *from PIL import ImagecaptchaUrl = &quot;https://xxx.com&quot; + &quot;/server?model=captcha&amp;action=getCaptcha&quot;req = urllib.request.Request(captchaUrl)res = urllib.request.urlopen(req)svg = res.read()def svgToPng(svgSource, outputName):    cairosvg.svg2png(bytestring=svgSource, write_to=&quot;temp\\%s&quot; % outputName)def _get_dynamic_binary_image(tag):    im = cv2.imread(&quot;temp\\%s.png&quot;%tag)    im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)  # 灰值化    # 二值化    th1 = cv2.adaptiveThreshold(im, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 21, 1)    cv2.imwrite(&quot;temp\\%s-binary.png&quot;%tag, th1)    return th1def corpCaptcha(tag):    image = cv2.imread(&quot;temp\\%s-binary.png&quot;%tag)    cv2.imwrite(&quot;temp\\%s_p1.png&quot;%tag, image[:, 10:40])    cv2.imwrite(&quot;temp\\%s_p2.png&quot;%tag, image[:, 30:60])    cv2.imwrite(&quot;temp\\%s_p3.png&quot;%tag, image[:, 55:85])    cv2.imwrite(&quot;temp\\%s_p4.png&quot;%tag, image[:, 80:110])def computeTestData(tag):    img1 = Image.open(&quot;temp\\%s_p1.png&quot;%tag)    img2 = Image.open(&quot;temp\\%s_p2.png&quot;%tag)    img3 = Image.open(&quot;temp\\%s_p3.png&quot;%tag)    img4 = Image.open(&quot;temp\\%s_p4.png&quot;%tag)    with open(&quot;temp\\%s_data.txt&quot;%tag,&quot;w&quot;) as f:        f.write(get_feature(img1,0)+&quot;\n&quot;)        f.write(get_feature(img2,0)+&quot;\n&quot;)        f.write(get_feature(img3,0)+&quot;\n&quot;)        f.write(get_feature(img4,0))def get_feature(img,label):    width, height = img.size    pixel_cnt_list = []    for y in range(height):        pix_cnt_x = 0        for x in range(width):            if img.getpixel((x, y)) == (0,0,0):  # 黑色点                pix_cnt_x += 1        pixel_cnt_list.append(pix_cnt_x)    for x in range(width):        pix_cnt_y = 0        for y in range(height):            if img.getpixel((x, y)) == (0,0,0):  # 黑色点                pix_cnt_y += 1        pixel_cnt_list.append(pix_cnt_y)    return &quot;%d &quot;%label+&quot; &quot;.join([&quot;%d:%s&quot;%(i,j) for i,j in enumerate(pixel_cnt_list,1)])def recognCaptcha(svg,tag):    svgToPng(svg, &quot;%s.png&quot;%tag)    _get_dynamic_binary_image(tag)    corpCaptcha(tag)    computeTestData(tag)    m = svm_load_model(&apos;captcha.model&apos;)  # 读取模型    y, x = svm_read_problem(&quot;temp\\%s_data.txt&quot;%tag)    p_label, p_acc, p_val = svm_predict(y, x, m)    return p_labeldef asciiDecode(codeList):    m =map(lambda x:chr(int(x)),codeList)    ret = []    for i in m:        ret.append(i)    return &quot;&quot;.join(ret)def learn(tag,rightCode,local):         #rightCode=[&quot;a&quot;,&quot;G&quot;]      local=[1,2]    with open(&quot;train_data.txt&quot;, &quot;a&quot;) as f:        for j,i in enumerate(local):            if rightCode[j]!=&quot;o&quot;:                img = Image.open(&quot;temp\\%s_p%d.png&quot; % (tag,i))                f.write(&quot;\n&quot;+get_feature(img, ord(rightCode[j])))    y,x = svm_read_problem(&quot;train_data.txt&quot;)    m = svm_train(y,x,&quot;-t 0 -c 4 -b 1&quot;)    svm_save_model(&apos;captcha.model&apos;, m)          #保存模型if __name__ == &apos;__main__&apos;:    args = sys.argv    if args[1]==&quot;test&quot;:        code = recognCaptcha(svg, &quot;xy&quot;)        print(asciiDecode(code))    elif args[1]==&quot;learn&quot;:        learn(&quot;xy&quot;, args[2], [1, 2, 3, 4])        m = svm_load_model(&apos;captcha.model&apos;)  # 读取模型        y, x = svm_read_problem(&quot;temp\\xy_data.txt&quot;)        p_label, p_acc, p_val = svm_predict(y, x, m)        print(asciiDecode(p_label))    elif args[1]==&quot;reload&quot;:        if len(args)&lt;3:            config = &quot;&quot;        else:            config = args[2:]        y, x = svm_read_problem(&quot;train_data.txt&quot;)        m = svm_train(y, x,config)                      #最优参数： -t 0 -c 4 -b 1        svm_save_model(&apos;captcha.model&apos;, m)  # 保存模型</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;IBSVM软件包是台湾大学林智仁(Chih-Jen Lin)博士等用C++实现的LIBSVM库，可以说是使用最方便的SVM训练工具[71]。可以解决分类问题(包括C-SVC、n-SVC)、回归问题(包括e-SVR、n-SVR)以及分布估计(one-c
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="libsvm" scheme="http://yoursite.com/tags/libsvm/"/>
    
      <category term="验证码识别" scheme="http://yoursite.com/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>python实现常用加密算法</title>
    <link href="http://yoursite.com/2018/07/18/python%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/18/python实现常用加密算法/</id>
    <published>2018-07-18T01:15:22.000Z</published>
    <updated>2018-07-18T02:16:32.964Z</updated>
    
    <content type="html"><![CDATA[<pre><code>需要用到的模块有系统自带的hashlib、base64、hmac，以及第三方模块pyCrypto</code></pre><h4 id="1、MD5加密"><a href="#1、MD5加密" class="headerlink" title="1、MD5加密"></a>1、MD5加密</h4><pre><code>import hashlibdef md5(data):    m = hashlib.md5()    m.update(data)    return m.hexdigest()</code></pre><h4 id="2、SHA256加密"><a href="#2、SHA256加密" class="headerlink" title="2、SHA256加密"></a>2、SHA256加密</h4><p>SHA256也称为HMAC_SHA256，hmac是Hash-based Message Authentication Code的简写，就是指哈希消息认证码，包含有很多种哈希加密算法，sha256是其中一种。</p><pre><code>import hashlib,base64,hmacdef hmac_sha256_encrypt(message,secret):    message = bytes(message).encode(&apos;utf-8&apos;)    secret = bytes(secret).encode(&apos;utf-8&apos;)    signature = base64.b64encode(hmac.new(secret, message, digestmod=hashlib.sha256).digest())    return signature</code></pre><h4 id="3、RSA加解密"><a href="#3、RSA加解密" class="headerlink" title="3、RSA加解密"></a>3、RSA加解密</h4><p>加密：  </p><pre><code>from Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5from Crypto.PublicKey import RSAimport base64,osdef rsa_encrypt(message):    pem_path = os.path.join(os.path.dirname(os.path.dirname(__file__)),&quot;exts&quot;,&quot;public.pem&quot;)    with open(pem_path) as f:        key = f.read()        rsakey = RSA.importKey(key)        cipher = Cipher_pkcs1_v1_5.new(rsakey)        cipher_text = base64.b64encode(cipher.encrypt(message))    return cipher_text</code></pre><p>解密：  </p><pre><code>from Crypto import Randomfrom Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5from Crypto.PublicKey import RSAimport base64,osdef rsa_decrypt(encrypt_text):    pem_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), &quot;exts&quot;, &quot;private.pem&quot;)    # 伪随机数生成器    random_generator = Random.new().read    with open(pem_path) as f:        key = f.read()        rsakey = RSA.importKey(key)        cipher = Cipher_pkcs1_v1_5.new(rsakey)        text = cipher.decrypt(base64.b64decode(encrypt_text), random_generator)    return text</code></pre><h4 id="4、SHA1withRSA加密"><a href="#4、SHA1withRSA加密" class="headerlink" title="4、SHA1withRSA加密"></a>4、SHA1withRSA加密</h4><p>这种加密方式常用于一般接口中做签名校验  </p><pre><code>import base64from Crypto.Signature import PKCS1_v1_5from Crypto.PublicKey import RSAfrom Crypto.Hash import SHAdef sign(data,pem):    private_key = RSA.importKey(pem)    cipher = PKCS1_v1_5.new(private_key)    h = SHA.new(data)    signature = cipher.sign(h)    return base64.b64encode(signature)</code></pre><h4 id="5、AES加解密"><a href="#5、AES加解密" class="headerlink" title="5、AES加解密"></a>5、AES加解密</h4><p>CBC模式：</p><pre><code>from Crypto.Cipher import AESimport base64def AES_CBC_encrypt(data, password, iv):    BS = AES.block_size    pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)    cipher = AES.new(password.encode(&quot;utf-8&quot;), AES.MODE_CBC, iv.encode(&quot;utf-8&quot;))    data = cipher.encrypt(pad(data.encode(&quot;utf-8&quot;)))    return base64.b64encode(data)def AES_CBC_decrypt(data, password, iv):    iv = iv.encode(&quot;utf-8&quot;)    data = iv + base64.b64decode(data.decode(&quot;utf-8&quot;))    bs = AES.block_size    if len(data) &lt;= bs:        return data    unpad = lambda s: s[0:-ord(s[-1])]    iv = data[:bs]    cipher = AES.new(password.encode(&quot;utf-8&quot;), AES.MODE_CBC, iv)    data = unpad(cipher.decrypt(data[bs:]))    return data</code></pre><p>ECB模式：</p><pre><code>from Crypto.Cipher import AESimport base64def AES_ECB_encrypt(data, password=&quot;yyfax10086100861&quot;):    BS = AES.block_size    pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)    cipher = AES.new(password.encode(&quot;utf-8&quot;), AES.MODE_ECB)    data = cipher.encrypt(pad(data.encode(&quot;utf-8&quot;)))    return base64.b64encode(data)def AES_ECB_decrypt(data, password=&quot;yyfax10086100861&quot;):    data = &quot;0&quot;*16 + base64.b64decode(data.decode(&quot;utf-8&quot;))    bs = AES.block_size    if len(data) &lt;= bs:        return data    unpad = lambda s: s[0:-ord(s[-1])]    cipher = AES.new(password.encode(&quot;utf-8&quot;), AES.MODE_ECB)    data = unpad(cipher.decrypt(data[bs:]))    return data</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;需要用到的模块有系统自带的hashlib、base64、hmac，以及
第三方模块pyCrypto
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;1、MD5加密&quot;&gt;&lt;a href=&quot;#1、MD5加密&quot; class=&quot;headerlink&quot; title=&quot;1、MD
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="crypto" scheme="http://yoursite.com/categories/python/crypto/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="加密算法" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>tornado学习总结（2）</title>
    <link href="http://yoursite.com/2018/07/02/tornado%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/02/tornado学习总结（2）/</id>
    <published>2018-07-02T03:28:21.000Z</published>
    <updated>2018-07-02T05:48:15.755Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇介绍tornado使用的基本知识点，这篇文章介绍tornado关键概念，以及目前经过几个项目优化后所采用的项目结构。  </p><h3 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h3><h4 id="1-1异步"><a href="#1-1异步" class="headerlink" title="1.1异步"></a>1.1异步</h4><p>&emsp;&emsp;即将进行的操作需要请求其它系统或其它函数去执行，而且当前主进程并不(立即)关心它们的执行结果，只是提供一个处理返回结果的函数入口给它们使用<br>&emsp;&emsp;<font color="#34A"><em>( eg.&emsp;去书店买书，请老板查找所需书是否存在，因为所有书的信息都已经录入电脑了，所以查找这个过程比较快，此时我就采用同步方式等待老板的查询结果，如果有的话就继续后面的买书过程；如果老板查询没有这本书，但是告诉我可以留下电话号码，等书进货到了，他会打电话通知我，我再选择购买方式，这个就是异步)</em></font></p><p>&emsp;&emsp;异步通信（前后端请求响应）和异步处理（系统内部处理）是不一样的，当描述前后端通信的时候，异步指的是前段非阻塞方式，同步指的是前端阻塞方式。异步可以是非阻塞或阻塞的。</p><h5 id="1-1-1-回调函数-def-buyBook"><a href="#1-1-1-回调函数-def-buyBook" class="headerlink" title="1.1.1 回调函数  def buyBook():"></a>1.1.1 回调函数  def buyBook():</h5><pre><code>def buyBookWay():    ***do buy book on line***if queryBookIsExist():    ***do buy book off line***else:    BookStore.stockBooks(tel,callback=buyBookWay)</code></pre><h5 id="1-1-2-协程-def-buyBook"><a href="#1-1-2-协程-def-buyBook" class="headerlink" title="1.1.2 协程   def buyBook():"></a>1.1.2 协程   def buyBook():</h5><pre><code>def buyBookWay():    ***do buy book on line***if queryBookIsExist():    ***do buy book off line***else:    yield BookStore.stockBooks(tel)    buyBookWay()</code></pre><h4 id="1-2-阻塞"><a href="#1-2-阻塞" class="headerlink" title="1.2 阻塞"></a>1.2 阻塞</h4><p>&emsp;&emsp;当所需要的资源（如cpu,数据库，IO等）被其它事件占用时，就会造成当前处理过程被阻塞。<br>&emsp;&emsp;tornado默认是单线程，在linux中tornado是基于epoll事件驱动框架，所以在网络时间上是无阻塞的，但是执行其它一些耗时操作的时候还是会阻塞其他请求</p><h3 id="2-项目结构"><a href="#2-项目结构" class="headerlink" title="2. 项目结构"></a>2. 项目结构</h3><pre><code>|--apps                          #应用目录    |--main                        #子应用        |--dao                    #数据库操作目录            |--dbCURD.py        |--service                #基础功能服务目录            |--bussiness.py        |--handlers.py            #url请求处理类目录(RequestHandler及其子类)        |--models.py             #数据库模型        |--tests.py                #测试用例        |--urls.py                #url路由定义    |--admin    |--app_x|--exts                          #应用需要的其他外部文件放到此目录    |--data.dat      |--private.pem      |--public.pem  |--libs                          #应用的第三方库放这里|--logs                          #日志文件目录|--plugin                          #公共组件服务目录    |--base.py    |--logger.py|--testSuit                        #测试集目录|--static                        #静态文件目录，setting中配置static_path指定，引用时使用{{static_url('相对路径')}}。前后端分离应用可删除该目录                      |--templates                    #模板文件目录,setting中配置template_path指定。前后端分离应用可删除该目录|--config.yml                    #配置文件|--server.py                    #应用入口，主执行文件|--urls.py                        #主路由文件|--setting.py                    #应用配置文件|--requirements.txt                #依赖包文件|--initDB.py                    #数据库初始化文件,创建数据库表</code></pre><h3 id="3-文件"><a href="#3-文件" class="headerlink" title="3. 文件"></a>3. 文件</h3><blockquote><p>file: /server.py</p></blockquote><pre><code>#coding = utff-8import tornado.ioloopimport tornado.httpserverimport tornado.optionsimport tornado.webfrom urls import urlsfrom setting import settingsfrom tornado.options import define,optionsapplication = tornado.web.Application(    handlers=urls,    **settings)define(&quot;port&quot;,default=8000,help=&quot;run on the given prot&quot;,type = int)def main():    tornado.options.parse_command_line()    http_server = tornado.httpserver.HTTPServer(application,xheaders=True)    http_server.listen(options.port)    print &quot;Development server is running at http://127.0.0.1:%s&quot;%options.port    print &quot;Quit the server with Control-C&quot;    tornado.ioloop.IOLoop.instance().start()if __name__ == &quot;__main__&quot;:    main()</code></pre><blockquote><p>file: /urls.py</p></blockquote><pre><code># coding=utf-8from importlib import import_modulefrom tornado.web import URLSpecimport sysreload(sys)sys.setdefaultencoding(&quot;utf-8&quot;)def include(module):    res = import_module(module)    urls = getattr(res, &apos;urls&apos;, res)    return urlsdef url_wrapper(urls):    &quot;&quot;&quot;    接受一个数组格式的参数，数组元素类型可以是以下几种情况：    1、   (r&apos;/a/&apos;, include(&apos;apps.main.urls&apos;),&quot;main&quot;),    2、   (r&apos;/x&apos;,TestHandler,&quot;test&quot;),    3、   URLSpec(r&apos;/x&apos;,TestHandler,name=&quot;test&quot;),    &quot;&quot;&quot;    wrapper_list = []    for url in urls:        if isinstance(url,URLSpec):            path, handles, name = url.regex.pattern,url.handler_class,url.name        else:            path, handles = url[0],url[1]            name = None if len(url)&lt;3 else url[2]        if isinstance(handles, (tuple, list)):            for handle in handles:                if isinstance(handle, URLSpec):                    pattern, handle_class, url_name = handle.regex.pattern, handle.handler_class, handle.name                else:                    pattern, handle_class = handle[0],handle[1]                    url_name = None if len(handle)&lt;3 else handle[2]                if name==None:                    retname = url_name                else:                    retname = name+&apos;_&apos;+url_name if url_name else None                wrapper_list.append(URLSpec(&apos;{0}{1}&apos;.format(path, pattern), handle_class,name=retname))        else:            wrapper_list.append(URLSpec(path, handles,name=name))    return wrapper_listurls = url_wrapper([    (r&apos;/main/&apos;,include(&apos;apps.main.urls&apos;),&quot;api&quot;),    (r&apos;/admin/&apos;,include(&apos;apps.admin.urls&apos;),&quot;admin&quot;)    ])</code></pre><blockquote><p>file: setting.py</p></blockquote><pre><code>#coding=utf-8import sysreload(sys)sys.setdefaultencoding(&apos;utf-8&apos;)import os,base64,uuidfrom sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom plugin.base import getCfgValueINSTALLED_APPS=[    &quot;apps.main&quot;,    &quot;apps.admin&quot;]DATABASE = {    &apos;DBDRIVER&apos;:&apos;mysqldb&apos;,    &apos;NAME&apos;:getCfgValue(&apos;mysql&apos;,&apos;dbname&apos;),    &apos;USER&apos;:getCfgValue(&apos;mysql&apos;,&apos;user&apos;),    &apos;PASSWORD&apos;:getCfgValue(&apos;mysql&apos;,&apos;password&apos;),    &apos;HOST&apos;:getCfgValue(&apos;mysql&apos;,&apos;host&apos;),    &apos;PORT&apos;:getCfgValue(&apos;mysql&apos;,&apos;port&apos;)}Base = declarative_base()engine = create_engine(&apos;mysql+{DBDRIVER}://{USER}:{PASSWORD}@{HOST}:{PORT}/{NAME}?charset=utf8&apos;.format(**DATABASE),pool_recycle=3600)settings=dict(    template_path = os.path.join(os.path.dirname(__file__),&quot;templates&quot;),    static_path = os.path.join(os.path.dirname(__file__),&quot;statics&quot;),    debug = False,    cookie_secret = base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes),              #用来使用get_secure_cookie方法    xsrf_cookies = False,    login_url = &apos;/mockServer/login&apos;,)</code></pre><blockquote><p>file: /plugin/logger.py</p></blockquote><pre><code>#coding=utf-8import os,datetime,syslog_path = os.path.join(os.path.dirname(os.path.dirname(__file__)),&quot;logs&quot;)def log(level,content,where):    now = str(datetime.datetime.today())    today = str(datetime.datetime.today().date())    filePath = os.path.join(log_path,&apos;log_&apos;+today+&apos;.log&apos;)    isErr = False    try:        content = content.decode(&quot;utf-8&quot;)    except:        isErr = True    if isErr:        try:            content = content.decode(sys.getfilesystemencoding())        except:            pass    with open(filePath,&apos;a&apos;) as f:        f.write((&apos;[%s][%s]%s [IN %s]\n&apos;%(level,now,content,where)).encode(sys.getfilesystemencoding()))def error(msg,where=&apos;unknown&apos;):    log(&apos;ERROR&apos;,msg,where)def info(msg,where=&apos;unknown&apos;):    log(&apos;INFO&apos;, msg, where)def warning(msg,where=&apos;unknown&apos;):    log(&apos;WARNING&apos;, msg, where)if __name__==&apos;__main__&apos;:    error(&apos;你的文件没有访问权限！&apos;,&apos;line 15-line 19&apos;)    info(&apos;访问http://www.baidu.com&apos;)    warning(&apos;删除/x/y/z成功！&apos;)</code></pre><blockquote><p>file: /apps/xxx/models.py</p></blockquote><pre><code>#coding=utf-8import sysreload(sys)sys.setdefaultencoding(&apos;utf-8&apos;)from sqlalchemy import Tablefrom sqlalchemy import Column,String,Integer,Text,ForeignKey,DateTime#常用字段类型有String,Integer，Text，Boolean，SmallInteger，DateTimefrom sqlalchemy.orm import relationshipfrom setting import Basefrom datetime import datetimeclass User(Base):    __tablename__ = &apos;users&apos;    id = Column(Integer, primary_key=True)    username = Column(String(64), nullable=False, index=True)    password = Column(String(64), nullable=False)    email = Column(String(64), nullable=False, index=True)    articles = relationship(&apos;Article&apos;, backref=&apos;author&apos;)                #relationship只描述关系，不定义字段    def __repr__(self):        return &apos;%s(%r)&apos; % (self.__class__.__name__, self.username)class UserInfo(Base):    __tablename__ = &apos;userinfos&apos;    id = Column(Integer, primary_key=True)    name = Column(String(64))    qq = Column(String(11))    phone = Column(String(11))    link = Column(String(64))    user_id = Column(Integer, ForeignKey(&apos;users.id&apos;))           #多方需要定义外键字段，指定唯一值(为什么不在一对多的唯一值方定义？因为那样子就无法从一查找到具体值)    user = relationship(&apos;User&apos;, backref=&apos;userinfo&apos;, uselist=False)  #定义一对一关系class Article(Base):    __tablename__ = &apos;articles&apos;    id = Column(Integer, primary_key=True)    title = Column(String(255), nullable=False, index=True)    content = Column(Text)    user_id = Column(Integer, ForeignKey(&apos;users.id&apos;))    cate_id = Column(Integer, ForeignKey(&apos;categories.id&apos;))    tags = relationship(&apos;Tag&apos;, secondary=&apos;article_tag&apos;, backref=&apos;articles&apos;)    createtime = Column(DateTime, default=datetime.now)    updatetime = Column(DateTime, default=datetime.now, onupdate=datetime.now)    def __repr__(self):        return &apos;%s(%r)&apos; % (self.__class__.__name__, self.title)class Category(Base):    __tablename__ = &apos;categories&apos;    id = Column(Integer, primary_key=True)    name = Column(String(64), nullable=False, index=True)    articles = relationship(&apos;Article&apos;, backref=&apos;category&apos;)    def __repr__(self):        return &apos;%s(%r)&apos; % (self.__class__.__name__, self.name)##  额外表，用来定义多对多关系  ###article_tag = Table(    &apos;article_tag&apos;, Base.metadata,    Column(&apos;article_id&apos;, Integer, ForeignKey(&apos;articles.id&apos;)),    Column(&apos;tag_id&apos;, Integer, ForeignKey(&apos;tags.id&apos;)))class Tag(Base):    __tablename__ = &apos;tags&apos;    id = Column(Integer, primary_key=True)    name = Column(String(64), nullable=False, index=True)    def __repr__(self):        return &apos;%s(%r)&apos; % (self.__class__.__name__, self.name)if __name__ == &quot;__main__&quot;:    pass</code></pre><blockquote><p>file: /apps/xxx/urls.py</p></blockquote><pre><code># coding=utf-8from handlers import IndexHandler, LoginHandler, NewProjectHandler, ListAllProjectsHandler, NewModuleHandler, \    GetProjectNameHandler, ListProjectModulesHandler, NewApiHandler, ListProjectApis, GetProjectDescHandler, \    ListApisByMidHandler, GetApiDataHandler, SaveApiDataHandler, ListAllResponseTypesHandler, GetConsulEnvInfoHandler, \    SaveConsulEnvInfoHandler,GetAuthInfoHandler,LogoutHandlerfrom tornado.web import urlurls = [    url(r&apos;&apos;, IndexHandler, name=&quot;index&quot;),    url(r&apos;login&apos;, LoginHandler, name=&apos;login&apos;),    url(r&apos;logout&apos;, LogoutHandler, name=&apos;logout&apos;),    url(r&apos;getauthinfo&apos;, GetAuthInfoHandler, &apos;getauthinfo&apos;),    url(r&apos;newProject&apos;, NewProjectHandler, name=&apos;newProject&apos;),    url(r&apos;listAllProjects&apos;, ListAllProjectsHandler, name=&apos;listAllProjects&apos;),    url(r&apos;newModule&apos;, NewModuleHandler, name=&apos;newModule&apos;),    url(r&apos;getProjectName&apos;, GetProjectNameHandler, name=&apos;getProjectName&apos;),    url(r&apos;listProjectModules&apos;, ListProjectModulesHandler, name=&apos;listProjectModules&apos;),    url(r&apos;newApi&apos;, NewApiHandler, name=&apos;newApi&apos;),    url(r&apos;listProjectApis&apos;, ListProjectApis, name=&apos;listProjectApis&apos;),    url(r&apos;getProjectDesc&apos;, GetProjectDescHandler, name=&apos;getProjectDesc&apos;),    url(r&apos;listApisByMid&apos;, ListApisByMidHandler, name=&apos;listApisByMid&apos;),    url(r&apos;getApiData&apos;, GetApiDataHandler, name=&apos;getApiData&apos;),    url(r&apos;saveApiData&apos;, SaveApiDataHandler, name=&apos;saveApiData&apos;),    url(r&apos;listAllResponseTypes&apos;, ListAllResponseTypesHandler, name=&apos;listAllResponseTypes&apos;),    url(r&apos;getConsulEnvInfo&apos;, GetConsulEnvInfoHandler, name=&apos;getConsulEnvInfo&apos;),    url(r&apos;saveConsulEnvInfo&apos;, SaveConsulEnvInfoHandler, name=&apos;saveConsulEnvInfo&apos;),]</code></pre><blockquote><p>file: /apps/xxx/handlers.py</p></blockquote><pre><code># coding=utf-8import tornado.webimport tornado.concurrentimport tornado.genfrom concurrent.futures import ThreadPoolExecutorfrom plugin import loggerfrom dao.main_curd import *import sys, time, jsonfrom tornado.httpclient import HTTPRequesttry:    from tornado.curl_httpclient import CurlAsyncHTTPClient as AsyncHTTPClientexcept ImportError:    from tornado.simple_httpclient import SimpleAsyncHTTPClient as AsyncHTTPClientreload(sys)sys.setdefaultencoding(&apos;utf8&apos;)_result = {}  # 存储格式为：_result[tid]={&apos;status&apos;: &apos;success&apos;, &apos;msg&apos;: context}TIMEOUT = 30MAX_WORKERS = 50class BaseHandler(tornado.web.RequestHandler):    executor = ThreadPoolExecutor(max_workers=MAX_WORKERS)    def get_current_user(self):        return self.get_secure_cookie(&quot;user&quot;)######### handler类异步处理编写方法 ##################前端同步获取结果####class Test1Handler(BaseHandler):    @tornado.concurrent.run_on_executor    def background_task(self):        # do some thing asynchronously        res = &apos;hello,world&apos;        return res    @tornado.gen.coroutine    def get(self):        res = yield self.background_task()        self.write(res)####前端异步获取结果######第一步，通知服务器执行处理，并生成、存储tid，并返回tid到前端class Test2Handler(BaseHandler):    @tornado.concurrent.run_on_executor    def background_task(self, tid):        try:            # do some thing asynchronously            res = {&apos;status&apos;: &apos;success&apos;, &apos;msg&apos;: &apos;&apos;}        except Exception, e:            res = {&apos;status&apos;: &apos;failed&apos;, &apos;msg&apos;: e.message}        _result[tid] = res    @tornado.gen.coroutine    def get(self):        tid = str(int(time.time() * 10000))        yield self.background_task(tid)        self.write(tid)    @tornado.gen.coroutine    def post(self):        tid = str(int(time.time() * 10000))        yield self.background_task(tid)        self.write(tid)# 第二步，根据tid查询结果内容class AsynGetResultHandler(BaseHandler):    @tornado.concurrent.run_on_executor    def background_task(self, tid, timeout):        start = time.time()        while not tid in _result.keys():            if time.time() - start &gt; timeout:                break            time.sleep(0.2)        if tid in _result.keys():            out = _result[tid]  # 结果            del _result[tid]  # 删除tid的数据。            return out        else:            return &quot;timeout.&quot;    @tornado.gen.coroutine    def get(self, timeout=TIMEOUT):        tid = self.get_argument(&quot;tid&quot;)        res = yield self.background_task(tid, timeout)        self.write(res)</code></pre><blockquote><p>file: /apps/xxx/dao/dbCURD.py</p></blockquote><pre><code># coding=utf-8import sys, jsonreload(sys)sys.setdefaultencoding(&apos;utf-8&apos;)from setting import enginefrom sqlalchemy.orm import sessionmakerfrom apps.main.service.consulOPT import getService,getAllService,newAgentfrom apps.main.models import *Session = sessionmaker(bind=engine)#############新增、创建#####################def addUser(account, passwd, email, role, name=&apos;&apos;, status=True):    session = Session()    user = User(account=account, name=name, passwd=passwd, email=email, role=role, status=status)    session.add(user)    try:        session.commit()    except Exception, e:        session.rollback()        raise e    finally:        ret = user.id        session.close()    return ret</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;上一篇介绍tornado使用的基本知识点，这篇文章介绍tornado关键概念，以及目前经过几个项目优化后所采用的项目结构。  &lt;/p&gt;
&lt;h3 id=&quot;1-基础概念&quot;&gt;&lt;a href=&quot;#1-基础概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="webServer" scheme="http://yoursite.com/tags/webServer/"/>
    
  </entry>
  
  <entry>
    <title>tornado学习总结（1）</title>
    <link href="http://yoursite.com/2018/07/02/tornado%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/02/tornado学习总结（1）/</id>
    <published>2018-07-02T01:49:30.000Z</published>
    <updated>2018-07-02T07:05:20.573Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要记录Tornado基本知识，以后知识点忘了可做查询用。Tornado大体上可以被分为4个主要部分：   </p><ul><li>web框架（包括创建web应用的<code>RequestHandler</code>类，还有很多其他支持的类）  </li><li>HTTP客户端和服务端实现 （HTTPServer、AsyncHTTPClient)</li><li>异步网络库（IOLoop、IOStream），为HTTP组件提供构建模块，也可以用来实现其他协议</li><li>携程库（tornado.gen)，允许异步代码写的更直接而不用链式回调的方式  </li></ul><hr><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li><h5 id="定义urls-并将urls绑定到处理类："><a href="#定义urls-并将urls绑定到处理类：" class="headerlink" title="定义urls,并将urls绑定到处理类："></a>定义urls,并将urls绑定到处理类：</h5><p> <code>app = tornado.web.Application(handlers=[(r&quot;/&quot;,IndexHandler)])</code><br> Application可以接受更多的配置项：  </p><pre><code>settings=dict(    template_path = os.path.join(os.path.dirname(__file__),&quot;templates&quot;),    static_path = os.path.join(os.path.dirname(__file__),&quot;statics&quot;),    debug = False,    cookie_secret = base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes),              #用来使用get_secure_cookie方法    xsrf_cookies = False,    login_url = &apos;/mockServer/login&apos;)urls = [(r&quot;/&quot;,IndexHandler)]application = tornado.web.Application(handlers=urls,**settings)  </code></pre></li><li><h5 id="绑定app-包含各种url信息-到http-server："><a href="#绑定app-包含各种url信息-到http-server：" class="headerlink" title="绑定app(包含各种url信息)到http_server："></a>绑定app(包含各种url信息)到http_server：</h5><p> <code>http_server = tornado.httpserver.HTTPServer(app)</code>  </p></li><li><h5 id="启动server监听（指定端口）："><a href="#启动server监听（指定端口）：" class="headerlink" title="启动server监听（指定端口）："></a>启动server监听（指定端口）：</h5><p> <code>http_server.listen(options.port)</code>  </p></li><li><h5 id="加入到循环事务中-并启动事务："><a href="#加入到循环事务中-并启动事务：" class="headerlink" title="加入到循环事务中,并启动事务："></a>加入到循环事务中,并启动事务：</h5><p> <code>tornado.ioloop.IOLoop.instance().start()</code>  </p></li><li><h5 id="处理类IndexHandler继承自tornado-web-RequestHandler-需要覆盖其get或post等方法。写内容到网页可以用：-self-write-字符串-，或者self-render-模版文件-key1-value1-模版文件中使用来引用对象-value1可以是list等复杂类型"><a href="#处理类IndexHandler继承自tornado-web-RequestHandler-需要覆盖其get或post等方法。写内容到网页可以用：-self-write-字符串-，或者self-render-模版文件-key1-value1-模版文件中使用来引用对象-value1可以是list等复杂类型" class="headerlink" title="处理类IndexHandler继承自tornado.web.RequestHandler,需要覆盖其get或post等方法。写内容到网页可以用： self.write(字符串)，或者self.render(模版文件,key1=value1),模版文件中使用来引用对象,value1可以是list等复杂类型"></a>处理类IndexHandler继承自tornado.web.RequestHandler,需要覆盖其get或post等方法。写内容到网页可以用： self.write(字符串)，或者self.render(模版文件,key1=value1),模版文件中使用来引用对象,value1可以是list等复杂类型</h5></li><li><h5 id="RequestHandler类有读写cookie的方法："><a href="#RequestHandler类有读写cookie的方法：" class="headerlink" title="RequestHandler类有读写cookie的方法："></a>RequestHandler类有读写cookie的方法：</h5><p> <code>set_cookie()</code> / <code>get_cookie()</code><br> 使用更安全的方式：<code>set_secure_cookie()</code>   /    <code>get_secure_cookie()</code>  ，此时需要在Application的setting中增加如下设置：<br> <code>cookie_secret = base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes)</code><br> （<code>set_secure_cookie</code>中加上<code>httponly=True, secure=True</code>更加安全）<br> 清理指定cookie：<code>clear_cookie(&#39;指定名称&#39;)</code></p></li><li><h5 id="开启-XSRF-保护："><a href="#开启-XSRF-保护：" class="headerlink" title="开启 XSRF 保护："></a>开启 XSRF 保护：</h5><p> a) 在Application的setting中增加如下设置：<code>xsrf_cookies = True</code><br> b) 在模板文件中的表单里面加入如下标记：</p><pre><code>{% raw xsrf_form_html () %}</code></pre><p> c) 在ajax中增加标记：</p><pre><code>function getCookie(name){    var x = document.cookie.match(&quot;\\b&quot; + name + &quot;=([^;]*)\\b&quot;);    return x ? x[1]:undefined;}$(document).ready(function(){    $(&quot;#login&quot;).click(function(){        var user = $(&quot;#username&quot;).val();        var pwd = $(&quot;#password&quot;).val();        var pd = {&quot;username&quot;:user, &quot;password&quot;:pwd, &quot;_xsrf&quot;:getCookie(&quot;_xsrf&quot;)};        $.ajax({            type:&quot;post&quot;,            url:&quot;/&quot;,            async:true,            data:pd,            cache:false,            success:function(data){                window.location.href = &quot;/user?user=&quot;+data;            },            error:function(){                alert(&quot;error!&quot;);            },        });    });});  </code></pre></li><li><h5 id="json和python对象互相转换："><a href="#json和python对象互相转换：" class="headerlink" title="json和python对象互相转换："></a>json和python对象互相转换：</h5><p> <code>tornado.escape.json_encode</code>(python对象)==&gt;json字符串<br> <code>tornado.escape.json_decode</code>(json字符串)==&gt;python对象<br> 它们与json 模块中的 dump()、load()功能相仿。  </p></li><li><h5 id="用户认证："><a href="#用户认证：" class="headerlink" title="用户认证："></a>用户认证：</h5><p> a) 具体的Handler的get方法加装饰器：<code>@tornado.web.authenticated</code><br> b) 可以使用<code>self.current_user</code>变量获取当前用户<br> c) a/b中的用法实际都会调用当前Handler类的<code>get_current_user</code>方法，所以前提是需要重载<code>get_current_user</code>方法，才可以使用。一般编写<code>BaseHandler(tornado.web.RequestHandler)</code>基类，里面实现<code>get_current_user</code>方法的重载，然后其他类继承自BaseHandler类<br> d) 若当前用户不存在（即<code>get_current_user</code>返回None时），使用调用装饰器或者<code>current_user</code>变量的时候，会寻找Application里setting的<code>login_url</code>指定的路径  </p></li><li><h5 id="异步与阻塞："><a href="#异步与阻塞：" class="headerlink" title="异步与阻塞："></a>异步与阻塞：</h5><p>【异步阻塞】  </p><pre><code>a) 设置异步函数结束后不断开服务器连接，使用`@tornado.web.asynchronous`装饰器。(原理是设置`_auto_finish`值为False,直到执行到`self.finish()`才关闭连接)  b) 使用`tornado.ioloop.IOLoop.instance().add_timeout(time.time() + 17, callback=self.on_response)` 设置超时时间，以及所要执行的回调函数  C) 编写回调函数，并在函数最后加上`self.finish()`调用      class SleepHandler(BaseHandler):        @tornado.web.asynchronous        def get(self):            tornado.ioloop.IOLoop.instance().add_timeout(time.time() + 17, callback=self.on_response)        def on_response(self):            self.render(&quot;sleep.html&quot;)            self.finish()      =======另一种写法=========      class SleepHandler(tornado.web.RequestHandler):        @tornado.gen.coroutine        def get(self):            yield tornado.gen.Task(tornado.ioloop.IOLoop.instance().add_timeout, time.time() + 17)            #yield tornado.gen.sleep(17)            self.render(&quot;sleep.html&quot;)</code></pre><p>【异步非阻塞】  </p><pre><code>python2.7需要安装concurrent模块：`@tornado.concurrent.run_on_executor`  TIMEOUT = 30MAX_WORKERS = 50class BaseHandler(tornado.web.RequestHandler):    executor = ThreadPoolExecutor(max_workers=MAX_WORKERS)  </code></pre></li><li><h5 id="异步函数编写："><a href="#异步函数编写：" class="headerlink" title="异步函数编写："></a>异步函数编写：</h5><pre><code>@tornado.gen.coroutine  def sleep(self):    yield tornado.gen.sleep(10)    raise tornado.gen.Return(&apos;hello world!&apos;)</code></pre></li><li><h5 id="完整实例："><a href="#完整实例：" class="headerlink" title="完整实例："></a>完整实例：</h5><pre><code>#coding=utf-8import tornado.httpserverimport tornado.ioloopimport tornado.optionsimport tornado.webfrom tornado.options import define,optionsdefine(&quot;port&quot;,default=8000,help=&quot;run on the given port&quot;,type=int)class IndexHandler(tornado.web.RequestHandler):    def get(self):        greeting = self.get_argument(&apos;greeting&apos;,&apos;Hello&apos;)        #get_argument返回的是unicode编码        self.write(greeting+&apos;,world!&apos;)if __name__==&quot;__main__&quot;:    tornado.options.parse_command_line()    app = tornado.web.Application(handlers=[(r&quot;/&quot;,IndexHandler)])    http_server = tornado.httpserver.HTTPServer(app)    http_server.listen(options.port)    tornado.ioloop.IOLoop.instance().start()  </code></pre><p>•    <strong>tornado.httpserver</strong>：这个模块就是用来解决 web 服务器的 http 协议问题，它提供了不少属性方法，实现客户端和服务器端的互通。Tornado 的非阻塞、单线程的特点在这个模块中体现。<br>•    <strong>tornado.ioloop</strong>：这个也非常重要，能够实现非阻塞 socket 循环，不能互通一次就结束呀。<br>•    <strong>tornado.options</strong>：这是命令行解析模块，也常用到。执行终端help命令时出现的提示。<br>•    <strong>tornado.web</strong>：这是必不可少的模块，它提供了一个简单的 Web 框架与异步功能，从而使其扩展到大量打开的连接，使其成为理想的长轮询。  </p></li><li><h5 id="模版："><a href="#模版：" class="headerlink" title="模版："></a>模版：</h5><p>1） for循环:  </p><pre><code>{% for i in key1 %}    {{i[0]}}{% end %}</code></pre><p>2） 书写python表达式：<br>&emsp;&emsp;使用双括号：<code>7</code><br>3) 调试模板：</p><pre><code>from tornado.template import Templateprint Template(&quot;{{ 'python'[0:2] }}&quot;).generate()    #输出py  </code></pre><p>4) 编写python语句：for,if,try，while等,可以多层嵌套  </p><pre><code>{% 语句 %}    ....{% end %}</code></pre><p>5) 设置变量：<code></code><br>6) 对变量x不进行html转义：    </p><pre><code>{% raw x %}  </code></pre><p>7) 常用模板函数：  </p><pre><code>escape(s)：替换字符串 s 中的 &amp;、&lt;、&gt; 为他们对应的 HTML 字符。url_escape(s)：使用 urllib.quote_plus 替换字符串 s 中的字符为 URL 编码形式。json_encode(val)：将 val 编码成 JSON 格式。squeeze(s)：过滤字符串 s，把连续的多个空白字符替换成一个空格。  </code></pre></li><li><h5 id="模板继承："><a href="#模板继承：" class="headerlink" title="模板继承："></a>模板继承：</h5><p>1） 父模板：</p><pre><code>{% block 继承块名称 %}    默认内容{% end %}</code></pre><p>2） 子模板：</p><pre><code>{% extends "base.html" %}{% block 继承块名称 %}    更新内容{% end %}</code></pre></li><li><h5 id="模板组件："><a href="#模板组件：" class="headerlink" title="模板组件："></a>模板组件：</h5><p>模板中引入其它模板：</p><pre><code>{% module Template("message.html", message=message) %}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要记录Tornado基本知识，以后知识点忘了可做查询用。Tornado大体上可以被分为4个主要部分：   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;web框架（包括创建web应用的&lt;code&gt;RequestHandler&lt;/code&gt;类，还有很多其他支持的类）  &lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="webServer" scheme="http://yoursite.com/tags/webServer/"/>
    
  </entry>
  
  <entry>
    <title>vue.js全局消息组件</title>
    <link href="http://yoursite.com/2018/06/28/vue-js%E5%85%A8%E5%B1%80%E6%B6%88%E6%81%AF%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/06/28/vue-js全局消息组件/</id>
    <published>2018-06-28T02:34:08.000Z</published>
    <updated>2018-06-28T03:01:02.059Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里总结了一个简单的实现全局消息通知的方法，实现的效果如下图：<br><img src="/upload/global_message_notice.png" alt="imgName"><br>1、修改<code>/src/App.vue</code>文件，<template\>中增加消息控件，放在<code>&lt;router-view/&gt;</code>后面  </template\></p><pre><code>&lt;div class=&quot;ant-message&quot;&gt;    &lt;div class=&quot;ant-content&quot;&gt;      &lt;div class=&quot;ant-message-notice&quot;             :class=&quot;[type==&apos;success&apos;?&apos;ant-message-success&apos;:&apos;&apos;,                    type==&apos;error&apos;?&apos;ant-message-error&apos;:&apos;&apos;,                    type==&apos;info&apos;?&apos;ant-message-info&apos;:&apos;&apos;,                    type==&apos;warning&apos;?&apos;ant-message-warning&apos;:&apos;&apos;]&quot;&gt;          &lt;span&gt;{{message}}&lt;/span&gt;      &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>2、同样在<code>/src/App.vue</code>文件中，在<style\>中增加样式：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//不能加scoped  </style\></p><pre><code>.ant-message{    position: fixed;    z-index: -1;    width:100%;    top: 51px;  }  .ant-content{    font-family: &quot;Helvetica Neue For Number&quot;, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;    font-size: 14px;    line-height: 1.5;    color: rgba(0, 0, 0, 0.65);    -webkit-box-sizing: border-box;    box-sizing: border-box;    pointer-events: none;    display: inline-block;  }  .ant-message-notice{    padding:16px 30px;    font-size: 16px;    color:black;    border-radius: 4px;    box-shadow:0 4px 12px rgba(0,0,0,0.15);    background: white;    display: none;    pointer-events: all;    box-sizing:border-box;  }  .ant-message-error:before{    content:&quot;\f057&quot;;    font-family: FontAwesome;    font-style: normal;    font-weight: normal;    font-size: 18px;    margin-right:5px;    z-index: 3;    color:red;  }  .ant-message-info:before{    content:&quot;\f05a&quot;;    font-family: FontAwesome;    font-style: normal;    font-weight: normal;    font-size: 18px;    margin-right:5px;    z-index: 3;    color: #4d7dff;  }  .ant-message-warning:before{    content:&quot;\f071&quot;;    font-family: FontAwesome;    font-style: normal;    font-weight: normal;    font-size: 18px;    margin-right:5px;    z-index: 3;    color: #ffdd65;  }  .ant-message-success:before{    content:&quot;\f058&quot;;    font-family: FontAwesome;    font-style: normal;    font-weight: normal;    font-size: 18px;    margin-right:5px;    z-index: 3;    color: #3da638;  }</code></pre><p>3、 在src/main.js中增加全局函数（$message）：  </p><pre><code>Vue.prototype.$message = function(option){  $(&apos;.ant-message-notice span&apos;).html(option.text)  $(&apos;.ant-message-notice&apos;).addClass(&apos;ant-message-&apos;+option.type)  $(&apos;.ant-message&apos;).css(&apos;z-index&apos;,9999)  $ (&apos;.ant-message-notice&apos;).show ().delay (3000).fadeOut (function () {            $(&apos;.ant-message&apos;).css(&apos;z-index&apos;,-1)          });}</code></pre><p>4、在需要弹出消息提示的时候使用<code>this.$message({&quot;type&quot;: &quot;warning&quot;, &quot;text&quot;: &quot;message&quot;})</code>即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;这里总结了一个简单的实现全局消息通知的方法，实现的效果如下图：&lt;br&gt;&lt;img src=&quot;/upload/global_message_notice.png&quot; alt=&quot;imgName&quot;&gt;&lt;br&gt;1、修改&lt;code&gt;/src/App.vue&lt;/cod
      
    
    </summary>
    
      <category term="vue.js" scheme="http://yoursite.com/categories/vue-js/"/>
    
    
      <category term="vue.js" scheme="http://yoursite.com/tags/vue-js/"/>
    
      <category term="消息组件" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>vue.js学习总结（2）</title>
    <link href="http://yoursite.com/2018/06/28/vue.js%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/28/vue.js学习总结（2）/</id>
    <published>2018-06-28T02:20:46.000Z</published>
    <updated>2018-06-28T02:22:42.874Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇文章介绍了vue.js如何快速创建一个应用，以及相关的目录介绍，编译部署等问题。这一篇文章主要总结一些项目通用的用法。  </p><h4 id="1-添加jquery和Bootstrap支持"><a href="#1-添加jquery和Bootstrap支持" class="headerlink" title="1.添加jquery和Bootstrap支持"></a>1.添加jquery和Bootstrap支持</h4><p>&emsp;&emsp;1)在项目根路径下安装相应模块:<br>&emsp;&emsp;&emsp;&emsp;<code>cnpm install bootstrap jquery –save</code><br>&emsp;&emsp;2)增加jquery支持：<br>&emsp;&emsp;&emsp;&emsp;<code>//file:webpack.base.conf.js</code><br>&emsp;&emsp;&emsp;&emsp;头部增加    const webpack = require(‘webpack’)<br>&emsp;&emsp;&emsp;&emsp;module.exports模块里面增加：  </p><pre><code>plugins: [    new webpack.ProvidePlugin({        $: &quot;jquery&quot;,        jQuery: &quot;jquery&quot;,        &quot;windows.jQuery&quot;: &quot;jquery&quot;      })],</code></pre><p>&emsp;&emsp;&emsp;&emsp;最后在main.js中加入import $ from ‘jquery’,完成jquery的引入</p><p>&emsp;&emsp;3)增加bootstrap支持：<br>&emsp;&emsp;&emsp;&emsp;在入口文件main.js中加入：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>import &#39;./assets/css/bootstrap.min.css&#39;</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>import &#39;./assets/js/bootstrap.min&#39;</code><br>&emsp;&emsp;&emsp;&emsp;在assets文件中新增css、js、fonts文件夹，分别在里面放入指定的bootstrap文件  </p><h4 id="2-增加fontAwesome图标支持："><a href="#2-增加fontAwesome图标支持：" class="headerlink" title="2.增加fontAwesome图标支持："></a>2.增加fontAwesome图标支持：</h4><p>&emsp;&emsp;方案一：  在index.html中合适的地方增加：  </p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css&quot;&gt;  </code></pre><p>&emsp;&emsp;方案二： 在<a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">Font Awesome官网</a>下载资源包，将解压后的文件依次放入<code>/src/assets/</code>下的对应文件夹(没有则新建)中，然后在main.js中导入指定文件：</p><pre><code>import &apos;./assets/css/font-awesome.min.css&apos;  </code></pre><h4 id="3-使用js加密工具jsencript"><a href="#3-使用js加密工具jsencript" class="headerlink" title="3.使用js加密工具jsencript:"></a>3.使用js加密工具jsencript:</h4><p>&emsp;&emsp;安装jsencript模块：<br>&emsp;&emsp;&emsp;&emsp;<code>cnpm install jsencrypt --save</code><br>&emsp;&emsp;在需要的模块中使用：<br>&emsp;&emsp;&emsp;&emsp;<code>import JSEncrypt from &#39;jsencrypt&#39;</code>  </p><h4 id="4-根据环境设置不同变量值"><a href="#4-根据环境设置不同变量值" class="headerlink" title="4.根据环境设置不同变量值"></a>4.根据环境设置不同变量值</h4><p>&emsp;&emsp;对于开发/生产环境（development/production）设置不同的变量值，代码如下：  </p><pre><code>var runenv = process.env.NODE_ENVvar backend_url = runenv==&quot;development&quot;?&quot;http://localhost:8000/&quot;:&quot;/&quot;  </code></pre><h4 id="5-设置通用函数"><a href="#5-设置通用函数" class="headerlink" title="5.设置通用函数"></a>5.设置通用函数</h4><p>&emsp;&emsp;main.js里面设置，组件中引用方式为：<code>this.getQueryVariable（&quot;xxx&quot;）</code></p><pre><code>//获取get请求查询参数Vue.prototype.getQueryVariable = function (variable) {             var query = window.location.search.substring(1);           var vars = query.split(&quot;&amp;&quot;);           for (var i=0;i&lt;vars.length;i++) {                   var pair = vars[i].split(&quot;=&quot;);                 if(pair[0] == variable){return pair[1];}         }             return(false);       }//判断对象是否为空Vue.prototype.checkNone = function(obj){      if(obj == &apos;&apos; || obj == undefined || obj == null || obj == false){            return false      }else{return true}   }//获取cookie值：Vue.prototype.getCookie = function(name){    var r = document.cookie.match(&quot;\\b&quot; + name + &quot;=([^;]*)\\b&quot;);    return r ? r[1] : undefined;  }  </code></pre><h4 id="6-路由配置"><a href="#6-路由配置" class="headerlink" title="6.路由配置"></a>6.路由配置</h4><p>&emsp;&emsp;1）导入组件    import componentName from ‘@/components/x/y/…’<br>&emsp;&emsp;2）如果去掉url中带入的#号，则设置mode : ‘history’;   base : ‘/baseUri/‘<br>&emsp;&emsp;3）增加routes列表项，{path:’/abc’,name:’abc’,component : componentName}  </p><h4 id="7-路由匹配"><a href="#7-路由匹配" class="headerlink" title="7.路由匹配"></a>7.路由匹配</h4><p>&emsp;&emsp;若访问的uri不在路由配置中，则路由到404页面。设置/src/App.vue文件，增加mounted()函数如下：</p><pre><code>mounted(){    if(!this.$route.matched || this.$route.matched.length === 0){          window.location.href = this.getBackendUrl()+&apos;errorpage/404/404.html?path=&apos;+this.$route.path    }}</code></pre><h4 id="8-拖拽排序"><a href="#8-拖拽排序" class="headerlink" title="8.拖拽排序"></a>8.拖拽排序</h4><p>&emsp;&emsp;a) 项目路径下执行<code>npm install awe-dnd --save</code><br>&emsp;&emsp;b) main.js中引入：  </p><pre><code>import VueDND from &apos;awe-dnd&apos;Vue.use(VueDND)</code></pre><p>&emsp;&emsp;c) template中引用：  </p><pre><code>&lt;div class=&quot;header-list&quot;&gt;&lt;div class=&quot;header-item&gt;    v-for=&quot;requestHeader in requestHeaders&quot;   v-dragging=&quot;{ item: requestHeader, list: requestHeaders, group: &apos;requestHeader&apos; }&quot;  :key=&quot;requestHeader.id&quot; :id=&quot;&apos;requestHeader&apos;+requestHeader.id&quot;&gt;    ....内容...&lt;/div&gt;&lt;/div&gt;</code></pre><p>&emsp;&emsp;d) requestHeaders内容：  </p><pre><code>[{&quot;id&quot;:1,&quot;value&quot;:&quot;x&quot;},{&quot;id&quot;:2,&quot;value&quot;:&quot;y&quot;},...]</code></pre><p>&emsp;&emsp;e) 添加事件：  </p><pre><code>export default {  mounted () {    this.$dragging.$on(&apos;dragged&apos;, ({ value }) =&gt; {      console.log(value.item)      console.log(value.list)      console.log(value.otherData)    })    this.$dragging.$on(&apos;dragend&apos;, () =&gt; {    })  }}</code></pre><p>&emsp;&emsp;附录：<br>&emsp;&emsp;&emsp;&emsp;设定行内部分元素拖拽的方法：<br>&emsp;&emsp;&emsp;&emsp;1）给需要拖拽的元素增加属性：draggable=”true”，并修改光标style=”cursor:move;”<br>&emsp;&emsp;&emsp;&emsp;2）修改awe-dnd源码，在文件vue-dragging.es5.js和vue-dragging.js中，注释掉这一行：el.setAttribute(‘draggable’, ‘true’);</p><h4 id="9-安装调试工具"><a href="#9-安装调试工具" class="headerlink" title="9.安装调试工具"></a>9.安装调试工具</h4><p>&emsp;&emsp;a) 全局安装<code>cnpm install -g @vue/devtools</code><br>&emsp;&emsp;b) 运行：<code>vue-devtools</code><br>&emsp;&emsp;c) 在应用的<head>中增加：(发布的时候应该移除)<br>&emsp;&emsp;&emsp;&emsp;<code>&lt;script src=&quot;http://localhost:8098&quot;&gt;&lt;/script&gt;</code><br>&emsp;&emsp;&emsp;&emsp;如果是APP或远程机上执行的应用，则：  </head></p><pre><code>&lt;script&gt;  window.__VUE_DEVTOOLS_HOST__ = &apos;&lt;your-local-ip&gt;&apos; // default: localhost  window.__VUE_DEVTOOLS_PORT__ = &apos;&lt;devtools-port&gt;&apos; // default: 8098&lt;/script&gt;&lt;script src=&quot;http://&lt;your-local-ip&gt;:8098&quot;&gt;&lt;/script&gt;</code></pre><p>&emsp;&emsp;d) <code>npm run dev</code> 运行应用，devtools会自动连接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;上一篇文章介绍了vue.js如何快速创建一个应用，以及相关的目录介绍，编译部署等问题。这一篇文章主要总结一些项目通用的用法。  &lt;/p&gt;
&lt;h4 id=&quot;1-添加jquery和Bootstrap支持&quot;&gt;&lt;a href=&quot;#1-添加jquery和Boo
      
    
    </summary>
    
      <category term="vue.js" scheme="http://yoursite.com/categories/vue-js/"/>
    
    
      <category term="vue.js" scheme="http://yoursite.com/tags/vue-js/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue.js学习总结（1）</title>
    <link href="http://yoursite.com/2018/06/26/vue.js%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/26/vue.js学习总结（1）/</id>
    <published>2018-06-26T02:46:51.000Z</published>
    <updated>2018-06-26T11:32:39.176Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;提到Vue.js,都会提到MVVM架构，那么什么是MVVM呢？MVVM可以拆分成：View — ViewModel — Model三部分，如下图：<br><img src="/upload/mvvm.jpg" alt="imgName"><br>那么我们怎么理解MVVM呢？<br>上图中，左侧的View相当于我们的DOM内容，我们所看到的页面视图，右侧的Model相当于我们的数据对象，比如一个对象的信息：  </p><blockquote><p>{<br>name:”张三”,<br>age:21,<br>}  </p></blockquote><p>而中间的监控者就负责监控两侧的数据，并相对应地通知另一侧进行修改。比如：你在Model层中修改了name的值为：“李四”，那么View视图层显示的“张三”也会自动变成了“李四”，而这个过程就是有ViewModel来操作的，不需要你手动地去写代码去实现（你不用再手动操作DOM了）。</p><p>那么如何快速创建一个vue.js应用呢？  </p><h3 id="1-创建应用"><a href="#1-创建应用" class="headerlink" title="1.创建应用"></a>1.创建应用</h3><p>&emsp;&emsp;使用<code>vue-cli</code>工具配合webpack构建工具创建，依次执行如下命令：  </p><pre><code>//安装vue-cli  (若未安装vue-cli)    cnpm install --global vue-cli//创建应用myproject    vue init webpack myproject//安装所需node依赖包    cd myproject    npm init</code></pre><h3 id="2-运行应用-dev环境"><a href="#2-运行应用-dev环境" class="headerlink" title="2.运行应用(dev环境)"></a>2.运行应用(dev环境)</h3><p>&emsp;&emsp;在项目目录下，执行命令<code>npm run dev</code>,直到控制台显示<code>Your application is running here: http://localhost:8080</code>，表示应用创建成功，访问<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>即可查看。  </p><h3 id="3-目录介绍"><a href="#3-目录介绍" class="headerlink" title="3. 目录介绍"></a>3. 目录介绍</h3><pre><code>projectName    |--build           |--build.js(生产环境构建) / webpack.back.conf.js(配置webpack，增加Jquery) / webpack.dev.conf.js(添加模拟API返回数据)    |--config           |--index.js / dev.env.js / prod.env.js / test.env.js        (index.js配置静态路径相对位置，绑定主机指定IP、端口，关闭Eslint检测useEslint: false，）    |--src           |--assets                |--css / fonts / image / js        (静态文件目录)           |--components                |--自建vue文件        (由&lt;template&gt;&lt;script&gt;&lt;style&gt;三部分组成）           |--router                |--index.js            (路由配置，路由模式，history模式去掉url中的#号)           |--App.vue                (根组件，配置router-view，根据路由不同展示不同组件)           |--main.js                (引入vue框架，定义vue实例，绑定vue实例(#el)到index.html的DOM元素中去，引入根组件，引入路由）    |--index.html                    (主页内容)</code></pre><h3 id="4-应用编译"><a href="#4-应用编译" class="headerlink" title="4. 应用编译"></a>4. 应用编译</h3><p>&emsp;&emsp;在项目目录下，执行命令<code>npm run build</code>,编译完成后，在应用目录下生成<code>dist</code>文件夹，部署时只用到该文件夹即可。<br>&emsp;&emsp;默认生成的<code>index.html</code>在<code>dist</code>根目录下，若使用Nginx部署应用，则只需要配置如下：<br><pre>location ~<em> / {<br>    root /path/to/dist;                    // 将/path/to/dist修改为dist实际路径即可<br>    index login.html index.html;<br>    try_files $uri $uri/ /myproject/;<br>}</em></pre><br>若需要将站点访问的uri加上一个统一前缀，比如加上<code>/myproject</code>后，<code><a href="http://localhost:8080/login.html" target="_blank" rel="noopener">http://localhost:8080/login.html</a></code>变成<code><a href="http://localhost:8080/myproject/login.html" target="_blank" rel="noopener">http://localhost:8080/myproject/login.html</a></code>，此时如果直接访问则会提404，那么该如何处理呢？<br>&emsp;&emsp;最开始想到的办法是，修改<code>nginx.conf</code>，将<code>location ~ /</code>修改为<code>location ~* /myproject/</code>，结果发现实际请求的本地路径前面都会加上/myproject，所以这种方式不行。后来通过实践，要实现这种要求，可以有两种方式：<br>&emsp;&emsp;a) 在dist目录下新增一个目录myproject,并将<code>index.html</code>移动到这个目录下，这个时候访问就正常了。<br>&emsp;&emsp;b) 修改项目路径下<code>/config/index.js</code>文件，修改<code>build:index</code>里面的<code>../dist/index.html</code>为<code>../dist/project/index.html</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;提到Vue.js,都会提到MVVM架构，那么什么是MVVM呢？MVVM可以拆分成：View — ViewModel — Model三部分，如下图：&lt;br&gt;&lt;img src=&quot;/upload/mvvm.jpg&quot; alt=&quot;imgName&quot;&gt;&lt;br&gt;那么
      
    
    </summary>
    
      <category term="vue.js" scheme="http://yoursite.com/categories/vue-js/"/>
    
    
      <category term="vue.js" scheme="http://yoursite.com/tags/vue-js/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>python使用微服务之consul</title>
    <link href="http://yoursite.com/2018/06/25/python%E4%BD%BF%E7%94%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bconsul/"/>
    <id>http://yoursite.com/2018/06/25/python使用微服务之consul/</id>
    <published>2018-06-25T12:04:24.000Z</published>
    <updated>2018-06-26T01:58:16.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>安装python-consul模块：<code>pip install python-consul</code>  </p></blockquote><h4 id="1-注册服务"><a href="#1-注册服务" class="headerlink" title="1. 注册服务"></a>1. 注册服务</h4><p>&emsp;&emsp;使用<code>/v1/agent/service/register</code>这个HTTP APi来进行注册，注册的目标consul主机，可以是server，也可以是client，端口是8500。如果非本地主机注册，则需要目标主机启动consul时加上<code>-client 目标访问ip</code>，否则无法远程访问。 代码如下：  </p><pre><code>#coding=utf-8import urllib2,jsonregister_url = &quot;http://%s:8500/v1/agent/service/register&quot;%&quot;localhost&quot;register_data = {                    &quot;id&quot;: &quot;serviceID&quot;,                #服务ID，每个datacenter中唯一                    &quot;name&quot;: &quot;serviceName&quot;,            #服务名称，服务表示                    &quot;address&quot;: &quot;10.x.x.x&quot;,            #服务提供者的IP                    &quot;port&quot;: 8080,                    #服务提供者的端口                    &quot;tags&quot;: [&quot;dev&quot;],                    &quot;checks&quot;: [{&quot;http&quot;: &quot;http://localhost:8080/check&quot;,&quot;interval&quot;: &quot;5s&quot;}]                }request = urllib2.Request(register_url,data=json.dumps(register_data))request.add_header(&apos;Content-Type&apos;, &apos;application/json&apos;)request.get_method = lambda: &apos;PUT&apos;urllib2.urlopen(request)</code></pre><h4 id="2-删除服务"><a href="#2-删除服务" class="headerlink" title="2. 删除服务"></a>2. 删除服务</h4><p>&emsp;&emsp;使用<code>/v1/agent/service/deregister/[serviceID]</code>这个HTTP API来删除服务。删除和注册必须要在同一台consul主机上进行，不能通过A主机注册，又通过B主机删除。但发起注册和发起删除服务的主机可以不同。代码如下：</p><pre><code># coding=utf-8import urllib2deregister_service_url = &apos;http://%s:8500/v1/agent/service/deregister/serviceID&apos;%&quot;localhost&quot;request = urllib2.Request(deregister_service_url)request.add_header(&apos;Content-Type&apos;, &apos;application/json&apos;)request.get_method = lambda: &apos;PUT&apos;urllib2.urlopen(request)</code></pre><h4 id="3-获取Consul服务列表"><a href="#3-获取Consul服务列表" class="headerlink" title="3.获取Consul服务列表"></a>3.获取Consul服务列表</h4><p>&emsp;&emsp;consul中没有注册中心的概念，一般是通过consul client进行服务注册和服务发现，这台用来服务注册和服务发现的主机就是一个Agent,生成一个Agent的代码为<code>agent = consul.Consul(host=&#39;172.30.1.71&#39;, port=&quot;8500&quot;)</code>。列出某个agent上可供访问到的所有服务(即当前agent所在datacenter中的所有服务)的代码如下：</p><pre><code># coding=utf-8from consul import Consuldef getAllService(agent):   #agent = Consul(host=&apos;172.30.1.71&apos;, port=&quot;8500&quot;)    newestIndex,services = agent.catalog.services()            #(&apos;23452&apos;, {u&apos;test&apos;: [u&apos;dev&apos;], u&apos;consul&apos;: [], u&apos;mockPlatform&apos;: []})       ==&gt;{&apos;服务名1&apos;：[tag1,tag2,...],...}    servicesList = services.keys()    servicesList.remove(&apos;consul&apos;)           #排除掉名称为&apos;consul&apos;的服务,为server端自带服务    return servicesList</code></pre><h4 id="4-获取服务"><a href="#4-获取服务" class="headerlink" title="4. 获取服务"></a>4. 获取服务</h4><p>&emsp;&emsp;查找指定服务的服务提供者，并返回访问速度最快的主机。代码如下：</p><pre><code># coding=utf-8from consul import Consulimport re,requestsdef getConnectTime(url):    return requests.head(url).elapsed.total_seconds()def getService(agent,name):  # 负载均衡获取服务实例agent = Consul(host=&apos;172.30.1.71&apos;, port=&quot;8500&quot;)    newestIndex, nodeList = agent.catalog.service(name)    if not nodeList:        raise Exception(&apos;There is no service: [%s] can be used!&apos;%name)    dcset = set()  # DataCenter 集合 初始化    for service in nodeList:        dcset.add(service.get(&apos;Datacenter&apos;))    serviceList = []  # 服务列表 初始化    for dc in dcset:        newestIndex,healthNodeList =agent.health.service(name,dc=dc,passing=True)        for serv in healthNodeList:            node = serv.get(&apos;Node&apos;).get(&quot;Node&quot;)            healthNodeList = agent.health.checks(name)[1]            for i in healthNodeList:                if i.get(&apos;Node&apos;)!= node:                    continue                else:                    health_output = i.get(&apos;Output&apos;)                    health = re.search(r&apos;HTTP GET (http:.*): 2.*&apos;,health_output).group(1)            address = serv.get(&apos;Service&apos;).get(&apos;Address&apos;)            port = serv.get(&apos;Service&apos;).get(&apos;Port&apos;)            serviceList.append({&apos;address&apos;: address,&apos;port&apos;: port,&apos;health&apos;:health})    if len(serviceList) == 0:        raise Exception(&apos;no serveice can be used&apos;)    else:        ret = ()        fastest = None        for s in serviceList:            health = s.get(&apos;health&apos;)            http_conn_time = getConnectTime(health)            if not fastest:                fastest = http_conn_time                ret = (s[&apos;address&apos;], int(s[&apos;port&apos;]))            else:                if http_conn_time&lt;fastest:                    ret = (s[&apos;address&apos;], int(s[&apos;port&apos;]))        return ret</code></pre><h4 id="5-consul提供的所有HTTP-API"><a href="#5-consul提供的所有HTTP-API" class="headerlink" title="5.consul提供的所有HTTP API"></a>5.consul提供的所有HTTP API</h4><p>&emsp;&emsp;所有的endpoints主要分为以下类别：<br>&emsp;&emsp;&emsp;&emsp;<strong>kv</strong> - Key/Value存储<br>&emsp;&emsp;&emsp;&emsp;<strong>agent</strong> - Agent控制<br>&emsp;&emsp;&emsp;&emsp;<strong>catalog</strong> - 管理nodes和services<br>&emsp;&emsp;&emsp;&emsp;<strong>health</strong> - 管理健康监测<br>&emsp;&emsp;&emsp;&emsp;<strong>session</strong> - Session操作<br>&emsp;&emsp;&emsp;&emsp;<strong>acl</strong> - ACL创建和管理event - 用户Events<br>&emsp;&emsp;&emsp;&emsp;<strong>status</strong> - Consul系统状态  </p><pre><code>agent endpoints：  (agent endpoints用来和本地agent进行交互，一般用来服务注册和检查注册，支持以下接口)    /v1/agent/checks :                          返回本地agent注册的所有检查(包括配置文件和HTTP接口)    /v1/agent/services :                        返回【本地agent注册】的所有 服务。注意！！只能是本地注册的服务    /v1/agent/members :                         返回agent在集群的gossip pool中看到的成员    /v1/agent/self :                            返回本地agent的配置和成员信息    /v1/agent/join/&lt;address&gt; :                  触发本地agent加入node    /v1/agent/force-leave/&lt;node&gt;:               强制删除node    /v1/agent/check/register :                  在本地agent增加一个检查项，使用PUT方法传输一个json格式的数据    /v1/agent/check/deregister/&lt;checkID&gt; :      注销一个本地agent的检查项    /v1/agent/check/pass/&lt;checkID&gt; :            设置一个本地检查项的状态为passing    /v1/agent/check/warn/&lt;checkID&gt; :            设置一个本地检查项的状态为warning    /v1/agent/check/fail/&lt;checkID&gt; :            设置一个本地检查项的状态为critical    /v1/agent/service/register :                在本地agent增加一个新的服务项，使用PUT方法传输一个json格式的数据    /v1/agent/service/deregister/&lt;serviceID&gt; :  注销一个本地agent的服务项,用PUT请求Consul 的这个deregister接口，附上服务id就可以成功注销掉服务了（注意是服务实例的id，不是服务名catalog endpoints：  (catalog endpoints用来注册/注销nodes、services、checks)    /v1/catalog/register :                      Registers a new node, service, or check    /v1/catalog/deregister :                    Deregisters a node, service, or check    /v1/catalog/datacenters :                   Lists known datacenters    /v1/catalog/nodes :                         Lists nodes in a given DC    /v1/catalog/services :                      Lists services in a given DC    /v1/catalog/service/&lt;service&gt; :             Lists the nodes in a given service    /v1/catalog/node/&lt;node&gt; :                   Lists the services provided by a nodehealth endpoints：     (health endpoints用来查询健康状况相关信息，该功能从catalog中单独分离出来)    /v1/healt/node/&lt;node&gt;:                         返回node所定义的检查，可用参数dc=    /v1/health/checks/&lt;service&gt;:                 返回和服务相关联的检查，可用参数dc=    /v1/health/service/&lt;service&gt;:                 返回给定datacenter中给定node中service    /v1/health/state/&lt;state&gt;:                     返回给定datacenter中指定状态的服务，state可以是&quot;any&quot;, &quot;unknown&quot;, &quot;passing&quot;, &quot;warning&quot;, or &quot;critical&quot;，可用参数dc=session endpoints：     (session endpoints用来create、update、destory、query sessions)    /v1/session/create:                     Creates a new session    /v1/session/destroy/&lt;session&gt;:          Destroys a given session    /v1/session/info/&lt;session&gt;:             Queries a given session    /v1/session/node/&lt;node&gt;:                Lists sessions belonging to a node    /v1/session/list:                       Lists all the active sessionsacl endpoints：        (acl endpoints用来create、update、destory、query acl)    /v1/acl/create:                         Creates a new token with policy    /v1/acl/update:                         Update the policy of a token    /v1/acl/destroy/&lt;id&gt;:                   Destroys a given token    /v1/acl/info/&lt;id&gt;:                      Queries the policy of a given token    /v1/acl/clone/&lt;id&gt;:                     Creates a new token by cloning an existing token    /v1/acl/list:                           Lists all the active tokensstatus endpoints：    (status endpoints用来或者consul 集群的信息)    /v1/status/leader :                     返回当前集群的Raft leader    /v1/status/peers :                         返回当前集群中同事  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;安装python-consul模块：&lt;code&gt;pip install python-consul&lt;/code&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-注册服务&quot;&gt;&lt;a href=&quot;#1-注册服务&quot; class=&quot;header
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="consul" scheme="http://yoursite.com/categories/python/consul/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="consul" scheme="http://yoursite.com/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>python多进程编程</title>
    <link href="http://yoursite.com/2018/01/10/python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/10/python多进程编程/</id>
    <published>2018-01-10T01:24:47.000Z</published>
    <updated>2018-06-25T11:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Python由于全局锁GIL的存在，无法享受多线程带来的性能提升。multiprocessing包采用子进程的技术避开了GIL，使用multiprocessing可以进行多进程编程提高程序效率。  </p><h2 id="multiprocessing-Process对象"><a href="#multiprocessing-Process对象" class="headerlink" title="multiprocessing.Process对象"></a>multiprocessing.Process对象</h2><pre><code>from multiprocessing import Process#定义子进程处理函数def worker(a,b,c=3,d=6):    passp = Process(target=worker,name=&apos;run_worker&apos;,args=(1,2),kwargs={d:&apos;4&apos;})p.daemon = True        #设置子进程是否随父进程终止而自动终止，一定要在start方法调用之前设置p.start()p.join()</code></pre><p>&emsp;&emsp;Process对象的初始化参数为<span style="background:lightgrey">Process(group=None, target=None, name=None, args=(), kwargs={})</span>，其中group参数必须为None（为了与threading.Thread的兼容），target指向可调用对象（该对象在新的子进程中运行），name是为该子进程命的名字（默认是Proess-1,Process-2, …这样），args是被调用对象的位置参数的元组列表，kwargs是被调用对象的关键字参数。</p><p>&emsp;&emsp;子进程终结时会通知父进程并清空自己所占据的内存，在内核里留下退出信息(exit code，如果顺利运行，为0；如果有错误或异常状况，为大于零的整数)。父进程得知子进程终结后，需要对子进程使用wait系统调用，wait函数会从内核中取出子进程的退出信息，并清空该信息在内核中占据的空间。</p><p>&emsp;&emsp;如果父进程早于子进程终结，子进程变成孤儿进程，孤儿进程会被过继给init进程，init进程就成了该子进程的父进程，由init进程负责该子进程终结时调用wait函数。如果父进程不对子进程调用wait函数，子进程成为僵尸进程。僵尸进程积累时，会消耗大量内存空间。 可以设置子进程的daemon属性为True,则父进程终结时，自动终止该子进程。</p><p>&emsp;&emsp;如果在父进程中不调用子进程的<code>p.join（）</code>方法，则主进程与父进程并行工作。join方法的作用主要是(以下线程均可换为子进程)：  </p><ul><li>阻塞主进程（挡住，无法执行join以后的语句），专注执行多线程。  </li><li>多线程多join的情况下，依次执行各线程的join方法，前头一个结束了才能执行后面一个。  </li><li>无参数时，则等待到该线程结束，才开始执行下一个线程的join。  </li><li>设置参数后，则等待该线程这么长时间如果没有执行完就阻塞该线程。  <blockquote><h3 id="将进程定义为类"><a href="#将进程定义为类" class="headerlink" title="将进程定义为类"></a>将进程定义为类</h3><pre><code>import multiprocessingimport timeclass ClockProcess(multiprocessing.Process):    def __init__(self, interval):        multiprocessing.Process.__init__(self)        self.interval = interval    def run(self):        n = 5        while n &gt; 0:            print(&quot;the time is {0}&quot;.format(time.ctime()))            time.sleep(self.interval)            n -= 1    if __name__ == &apos;__main__&apos;:        p = ClockProcess(3)        p.start()</code></pre></blockquote></li></ul><h2 id="multiprocessing-Queue对象"><a href="#multiprocessing-Queue对象" class="headerlink" title="multiprocessing.Queue对象"></a>multiprocessing.Queue对象</h2><p>使用Queue对象可以实现进程间通信，并且Queue对象是线程及进程安全的：</p><pre><code>from multiprocessing import Queue, Processdef worker(q):    q.put([&apos;abc&apos;,123,&apos;x&apos;])if __name__ == &quot;__main__&quot;:    q = Queue()    p = Process(target = worker,args=(q,))    p.daemon = True    p.start()    p.join()    print q.get()</code></pre><h2 id="multiprocessing-Pipe对象"><a href="#multiprocessing-Pipe对象" class="headerlink" title="multiprocessing.Pipe对象"></a>multiprocessing.Pipe对象</h2><p>Pipe对象返回的元组分别代表管道的两端p[0]和p[1]，管道默认是全双工，两端都支持send和recv方法，两个进程分别操作管道两端时不会有冲突，两个进程对管道一端同时读写时可能会有冲突：</p><pre><code>from multiprocessing import Pipe, Processdef worker(p):    p.send(&apos;hello,world!&apos;)if __name__ == &quot;__main__&quot;:    left,right = Pipe()    p = Process(target=worker,args=(left,))    p.daemon = True    p.start()    p.join()    print right.recv()</code></pre><p>如果声明了p = Pipe(duplex=False)的单向管道，则p[0]只负责接受消息，p[1]只负责发送消息。  </p><h2 id="multiprocessing-Lock对象"><a href="#multiprocessing-Lock对象" class="headerlink" title="multiprocessing.Lock对象"></a>multiprocessing.Lock对象</h2><p>当多个进程需要访问共享资源的时候，Lock可以用来避免访问的冲突。<br>Lock有两种方法使用：1.使用with上下文管理器;2.使用acquire()和release()方法  </p><pre><code>import multiprocessingimport sysdef worker_with(lock, f):    with lock:        fs = open(f, &apos;a+&apos;)        n = 10        while n &gt; 1:            fs.write(&quot;Lockd acquired via with\n&quot;)            n -= 1        fs.close()def worker_no_with(lock, f):    lock.acquire()    try:        fs = open(f, &apos;a+&apos;)        n = 10        while n &gt; 1:            fs.write(&quot;Lock acquired directly\n&quot;)            n -= 1        fs.close()    finally:        lock.release()if __name__ == &quot;__main__&quot;:    lock = multiprocessing.Lock()    f = &quot;file.txt&quot;    w = multiprocessing.Process(target = worker_with, args=(lock, f))    nw = multiprocessing.Process(target = worker_no_with, args=(lock, f))    w.start()    nw.start()    print &quot;end&quot;</code></pre><h2 id="multiprocessing-Value-和-multiprocessing-Array对象"><a href="#multiprocessing-Value-和-multiprocessing-Array对象" class="headerlink" title="multiprocessing.Value 和 multiprocessing.Array对象"></a>multiprocessing.Value 和 multiprocessing.Array对象</h2><p>在进程间共享状态可以使用multiprocessing.Value和multiprocessing.Array这样特殊的共享内存对象：<br>&emsp;&emsp;<code>Value(typecode_to_type , obj)</code><br>&emsp;&emsp;<code>Array(typecode_to_type , int | list | tuple... , lock=True)</code><br>Array的第二个参数传入为int类型的一个数的时候，会初始化值为0长度为这个值的数组</p><pre><code>typecode_to_type = {    &apos;c&apos;: ctypes.c_char,    &apos;b&apos;: ctypes.c_byte,  &apos;B&apos;: ctypes.c_ubyte,    &apos;h&apos;: ctypes.c_short, &apos;H&apos;: ctypes.c_ushort,    &apos;i&apos;: ctypes.c_int,   &apos;I&apos;: ctypes.c_uint,    &apos;l&apos;: ctypes.c_long,  &apos;L&apos;: ctypes.c_ulong,    &apos;f&apos;: ctypes.c_float, &apos;d&apos;: ctypes.c_double    }</code></pre><p>读写Value数据用属性v.value,读写Array数据用切片运算a[i]</p><pre><code>from multiprocessing import Pipe, Process,Value,Arraydef worker(v,a):    v.value = 1.2    for i in range(10):        a[i] = -iif __name__ == &quot;__main__&quot;:    v = Value(&apos;f&apos;,0.0)    a = Array(&apos;i&apos;,range(10))    print v.value    print a[3]    p = Process(target=worker,args=(v,a))    p.daemon = True    p.start()    p.join()    print v.value    print a[3]</code></pre><h2 id="multiprocessing-Manager对象"><a href="#multiprocessing-Manager对象" class="headerlink" title="multiprocessing.Manager对象"></a>multiprocessing.Manager对象</h2><p>multiprocessing.Manager对象创建一个服务进程，像是一个保存状态的代理，其他进程通过与代理的接口通信取得状态信息，服务进程支持更多的数据类型，使用起来比共享内存更灵活。</p><pre><code>from multiprocessing import Process, Managerdef func(d, l):    d[&apos;1&apos;] = 2    d[2] = &apos;str&apos;    d[3.0] = None    for i in range(len(l)):        l[i] = -iif __name__ == &quot;__main__&quot;:    m = Manager()    l = m.list(range(10))    d = m.dict()    p = Process(target=func, args=(d, l,))    p.start()    p.join()    print d    print l</code></pre><h2 id="multiprocessing-Pool对象"><a href="#multiprocessing-Pool对象" class="headerlink" title="multiprocessing.Pool对象"></a>multiprocessing.Pool对象</h2><p>&emsp;&emsp;在利用Python进行系统管理的时候，特别是同时操作多个文件目录，或者远程控制多台主机，并行操作可以节约大量的时间。当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。<br>&emsp;&emsp;Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。</p><pre><code>#coding: utf-8import multiprocessingimport timedef func(msg):    print &quot;msg:&quot;, msg    time.sleep(3)    print &quot;end&quot;if __name__ == &quot;__main__&quot;:    pool = multiprocessing.Pool(processes = 3)    for i in xrange(4):        msg = &quot;hello %d&quot; %(i)        pool.apply_async(func, (msg, ))   #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去    print &quot;Mark~ Mark~ Mark~~~~~~~~~~~~~~~~~~~~~~&quot;    pool.close()    pool.join()   #调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束    print &quot;Sub-process(es) done.&quot;  </code></pre><p>函数解释：  </p><ul><li>apply_async(func[, args[, kwds[, callback]]]) 它是非阻塞，apply(func[, args[, kwds]])是阻塞的（理解区别，看例1例2结果区别）  </li><li>close()    关闭pool，使其不在接受新的任务  </li><li>terminate()    结束工作进程，不在处理未完成的任务。  </li><li>join()    主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。  </li></ul><p>执行说明：<br>&emsp;&emsp;创建一个进程池pool，并设定进程的数量为3，xrange(4)会相继产生四个对象[0, 1, 2, 4]，四个对象被提交到pool中，因pool指定进程数为3，所以0、1、2会直接送到进程中执行，当其中一个执行完事后才空出一个进程处理对象3，所以会出现输出“msg: hello 3”出现在”end”后。因为为非阻塞，主函数会自己执行自个的，不搭理进程的执行，所以运行完for循环后直接输出“mMsg: hark~ Mark~ Mark<del>~</del><del>~</del><del>~</del><del>~</del>~~”，主程序在pool.join（）处等待各个进程的结束。</p><h2 id="multiprocessing-Semaphore对象"><a href="#multiprocessing-Semaphore对象" class="headerlink" title="multiprocessing.Semaphore对象"></a>multiprocessing.Semaphore对象</h2><p>Semaphore用来控制对共享资源的访问数量，例如池的最大连接数。当连接数量达到设定值后，只有当旧的连接释放掉，才会为资源创建新连接。  </p><pre><code>import multiprocessingimport timedef worker(s, i):    s.acquire()    print(multiprocessing.current_process().name + &quot;acquire&quot;);    time.sleep(i)    print(multiprocessing.current_process().name + &quot;release\n&quot;);    s.release()if __name__ == &quot;__main__&quot;:    s = multiprocessing.Semaphore(2)    for i in range(5):        p = multiprocessing.Process(target = worker, args=(s, i*2))        p.start()</code></pre><h2 id="multiprocessing-Event对象"><a href="#multiprocessing-Event对象" class="headerlink" title="multiprocessing.Event对象"></a>multiprocessing.Event对象</h2><p>Event用来实现进程间同步通信。</p><pre><code>import multiprocessingimport timedef wait_for_event(e):    print(&quot;wait_for_event: starting&quot;)    e.wait()    print(&quot;wairt_for_event: e.is_set()-&gt;&quot; + str(e.is_set()))def wait_for_event_timeout(e, t):    print(&quot;wait_for_event_timeout:starting&quot;)    e.wait(t)    print(&quot;wait_for_event_timeout:e.is_set-&gt;&quot; + str(e.is_set()))if __name__ == &quot;__main__&quot;:    e = multiprocessing.Event()    w1 = multiprocessing.Process(name = &quot;block&quot;,            target = wait_for_event,            args = (e,))    w2 = multiprocessing.Process(name = &quot;non-block&quot;,            target = wait_for_event_timeout,            args = (e, 2))    w1.start()    w2.start()    time.sleep(3)    e.set()    print(&quot;main: event is set&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Python由于全局锁GIL的存在，无法享受多线程带来的性能提升。multiprocessing包采用子进程的技术避开了GIL，使用multiprocessing可以进行多进程编程提高程序效率。  &lt;/p&gt;
&lt;h2 id=&quot;multiprocessi
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="multiprocessing" scheme="http://yoursite.com/tags/multiprocessing/"/>
    
  </entry>
  
  <entry>
    <title>RF关联案例设置方法</title>
    <link href="http://yoursite.com/2018/01/08/RF%E5%85%B3%E8%81%94%E6%A1%88%E4%BE%8B%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/08/RF关联案例设置方法/</id>
    <published>2018-01-08T02:28:40.000Z</published>
    <updated>2018-06-25T11:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;虽然手工测试用例的编写规则一般建议，用例之间要尽量避免关联性，测试点要尽量独立，但如果在自动化领域，考虑到自动化的执行效率，以及自动化数据流之间的关联性，这种建议往往比较难以实现。比如说，测试一个用户登录之后的某些功能，必须要先在环境中注册好一个用户，在自动化中可实现的方法有两种：<br>&emsp;&emsp;1. 将已注册的用户设置成全局变量放入到配置文件中，每次新环境执行自动化用例前，手工生成一个已注册用户，再将该用户信息写入配置文件中去；<br>&emsp;&emsp;2. 单独写一条自动化用例实现注册功能，其它测试用例基于该注册用例产生的注册用户进一步执行；<br>&emsp;&emsp;方法1执行自动化前需要手工去准备数据，这里只列举出了一种场景，假如测试场景中有更多前置条件需要设置，则需要手工生成的数据也会很多，这种方法无疑是效率很低的一种半自动化；方法2也存在一种问题，在手工测试，如果测试人员要测试更多的已登录功能，一般都会先将注册更能调试通，能注册成功之后再会去测试其它功能，假如注册都失败了，后面的用例也不需要再执行了；但在自动化执行过程中，注册失败了，还是会继续执行后续用例，这将会导致自动化执行效率很低。<br>&emsp;&emsp;本文就是基于robot framework自动化，模拟手工测试过程解决方法2中存在的问题。  </p><p><strong>1. 重复执行单条用例N次，直到成功</strong></p><blockquote><p>参照上一篇文章 <a href="https://turbolento.github.io/2018/01/08/RF%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%94%A8%E4%BE%8B%E9%87%8D%E8%B7%91/" target="_blank" rel="noopener">RF执行失败用例重跑</a>  </p></blockquote><p><strong>2. 如果前置用例失败，则关联性用例直接标记失败</strong><br>2.1 自定义关键字  </p><table><thead><tr><th style="text-align:left"><span style="color:#42E205">关联案例集_案例初始化</span></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><span style="color:blue">初始化环境</span></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><span style="color:blue">Run Keyword If</span></td><td style="text-align:left">‘clearSuiteStatus’ in @{TEST_TAGS}</td><td style="text-align:left"><span style="color:blue">Set Suite Variable</span></td><td style="text-align:left">${suite_status}</td><td style="text-align:left">RUN</td></tr><tr><td style="text-align:left"><span style="color:blue">Run Keyword If</span></td><td style="text-align:left">‘${suite_status}’ == ‘INTERRUPT’</td><td style="text-align:left"><span style="color:blue">Fail</span></td><td style="text-align:left">前置条件设置失败！</td><td style="text-align:left">&nbsp;</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><span style="color:#42E205">关联案例集_案例集初始化</span></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><span style="color:blue">Set Suite Variable</span></td><td style="text-align:left">${suite_status}</td><td style="text-align:left">RUN</td><td style="text-align:left">#RUN/INTERRUPT</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><span style="color:#42E205">关联案例集_案例析构</span></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><span style="color:blue">Run Keyword If</span></td><td style="text-align:left">‘suite_init’ in @{TEST_TAGS} and ‘${TEST_STATUS}’ == ‘FAIL’</td><td style="text-align:left"><span style="color:blue">Set Suite Variable</span></td><td style="text-align:left">${suite_status}</td><td style="text-align:left">INTERRUPT</td></tr><tr><td style="text-align:left"><span style="color:blue">释放环境</span></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p>2.2 管理关联用例名称<br>&emsp;&emsp;采用尾部加上-[大小写字母]的方式：大写字母表示前置用例，对应的小写字母表示想关联的用例，如下图：<br><img src="/upload/rf_1.png" alt="imgName"></p><p>2.3 管理用例标签  </p><ul><li>-[A]不依赖任何用例，只被其它用例依赖，则添加标签<code>suite_init</code>、<code>clearSuiteStatus</code></li><li>-[a]只依赖其它用例，不被其它用例依赖，则不添加标签</li><li>-[a][B]依赖其它标签，也被其它标签依赖，则只添加标签<code>suite_init</code></li></ul><p>2.4 设置suite前置条件<br><img src="/upload/rf_2.png" alt="imgName"></p><p>执行命令<code>pybot -Z 3 -t * E:\auto\00正常流程用例</code> 即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;虽然手工测试用例的编写规则一般建议，用例之间要尽量避免关联性，测试点要尽量独立，但如果在自动化领域，考虑到自动化的执行效率，以及自动化数据流之间的关联性，这种建议往往比较难以实现。比如说，测试一个用户登录之后的某些功能，必须要先在环境中注册好一个用户
      
    
    </summary>
    
      <category term="自动化" scheme="http://yoursite.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="Robot Framework" scheme="http://yoursite.com/tags/Robot-Framework/"/>
    
  </entry>
  
  <entry>
    <title>RF执行失败用例重跑</title>
    <link href="http://yoursite.com/2018/01/08/RF%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%94%A8%E4%BE%8B%E9%87%8D%E8%B7%91/"/>
    <id>http://yoursite.com/2018/01/08/RF执行失败用例重跑/</id>
    <published>2018-01-08T01:06:34.000Z</published>
    <updated>2018-06-25T11:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文通过修改RF源代码，增加命令pybot参数–retry N,以实现执行过程中，test级别的用例失败后自动再执行N次，或直到成功为止，生成的日志和报告文件中只记录最后一次执行结果。<br><a id="more"></a><br><strong>修改代码如下：</strong>  </p><h4 id="1-robot-run-py"><a href="#1-robot-run-py" class="headerlink" title="1. robot/run.py"></a>1. robot/run.py</h4><p>修改USAGE文档，增加 -Z –retry retry&emsp;&emsp;&emsp;&emsp;Set the retry times if test failed.  </p><blockquote><h1 id="Options"><a href="#Options" class="headerlink" title="Options  "></a>Options  </h1><p><span style="background:yellow">-Z –retry retry&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Set the retry times if test failed.</span><br>-N –name name&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Set the name of the top level test suite. Underscores<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; in the name are converted to spaces. Default name is<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; created from the name of the executed data source.<br>-D –doc documentation&emsp;&emsp;&emsp;&nbsp; Set the documentation of the top level test suite.<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; Underscores in the documentation are converted to<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; spaces and it may also contain simple HTML formatting<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; (e.g. <em>bold</em> and <a href="http://url/" target="_blank" rel="noopener">http://url/</a>). </p></blockquote><p>增加导入模块  </p><pre><code>reload(sys)  sys.setdefaultencoding(&apos;UTF-8&apos;)from xml.dom import minidom</code></pre><p>RobotFramework类增加make方法  </p><pre><code>def make(self,outxml):    xmldoc = minidom.parse(outxml)    suiteElementList = xmldoc.getElementsByTagName(&apos;suite&apos;)    mySuite = []    for suiteElement in suiteElementList:        if suiteElement.childNodes is not None:            for element in suiteElement.childNodes:                if element.nodeName == &apos;test&apos;:                    mySuite.append(suiteElement)                    break    for suite in mySuite:        testElements = {}        for element in suite.childNodes:            if element.nodeName == &apos;test&apos;:                name = element.getAttribute(&apos;name&apos;)                if testElements.get(name) == None:                    testElements.update({name:[element]})                else:                    testElements.get(name).append(element)        for n,el in testElements.iteritems():            for i in el[0:-1]:                textElement = i.nextSibling                suite.removeChild(i)                suite.removeChild(textElement)    savefile = open(outxml,&apos;w&apos;)    root = xmldoc.documentElement    root.writexml(savefile)    savefile.close()</code></pre><p>修改RobotFramework类的main方法，插入self.make(settings.output)这段</p><pre><code>def main(self, datasources, **options):    settings = RobotSettings(options)    LOGGER.register_console_logger(**settings.console_output_config)    LOGGER.info(&apos;Settings:\n%s&apos; % unic(settings))    suite = TestSuiteBuilder(settings[&apos;SuiteNames&apos;],                         settings[&apos;WarnOnSkipped&apos;]).build(*datasources)    suite.configure(**settings.suite_config)    if settings.pre_run_modifiers:        suite.visit(ModelModifier(settings.pre_run_modifiers,                              settings.run_empty_suite, LOGGER))    with pyloggingconf.robot_handler_enabled(settings.log_level):        result = suite.run(settings)        LOGGER.info(&quot;Tests execution ended. Statistics:\n%s&quot;                % result.suite.stat_message)        self.make(settings.output)                #增加这一行,去掉此注释        if settings.log or settings.report or settings.xunit:            writer = ResultWriter(settings.output if settings.log                              else result)            writer.write_results(settings.get_rebot_settings())    return result.return_code</code></pre><h4 id="2-robot-conf-settings-py"><a href="#2-robot-conf-settings-py" class="headerlink" title="2. robot/conf/settings.py"></a>2. robot/conf/settings.py</h4><p>修改_cli_opts字典，增加 ‘Retry’:(‘retry’,1)  </p><pre><code>&apos;MonitorColors&apos;            : (&apos;monitorcolors&apos;, &apos;AUTO&apos;),&apos;StdOut&apos;                   : (&apos;stdout&apos;, None),&apos;StdErr&apos;                   : (&apos;stderr&apos;, None),&apos;XUnitSkipNonCritical&apos;  : (&apos;xunitskipnoncritical&apos;, False),&apos;Retry&apos;                    : (&apos;retry&apos;,1)}                #增加这一行,去掉此注释</code></pre><h4 id="3-robot-model-itemlist-py"><a href="#3-robot-model-itemlist-py" class="headerlink" title="3. robot/model/itemlist.py"></a>3. robot/model/itemlist.py</h4><p>修改visit方法如下:  </p><pre><code>def visit(self, visitor):    for item in self:        if self.__module__ == &apos;robot.model.testcase&apos; and hasattr(visitor,&quot;_context&quot;):            testStatus = &apos;&apos;            for i in range(0,int(visitor._settings._opts[&apos;Retry&apos;])):                if testStatus != &apos;PASS&apos;:                    if item.name in visitor._executed_tests:                        visitor._executed_tests.pop(item.name)                    item.visit(visitor)                    testStatus = visitor._context.variables[&apos;${PREV_TEST_STATUS}&apos;]                else:                    break        else:            item.visit(visitor)</code></pre><h4 id="4-robotide-contrib-testrunner-usages-py"><a href="#4-robotide-contrib-testrunner-usages-py" class="headerlink" title="4. robotide\contrib\testrunner\usages.py"></a>4. robotide\contrib\testrunner\usages.py</h4><p>修改USAGE文档，增加 -Z –retry retry&emsp;&emsp;&emsp;&emsp;Set the retry times if test failed.这一段  </p><blockquote><h1 id="Options-1"><a href="#Options-1" class="headerlink" title="Options  "></a>Options  </h1><p><span style="background:yellow">-Z –retry retry&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Set the retry times if test failed.</span><br>-N –name name&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Set the name of the top level test suite. Underscores<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; in the name are converted to spaces. Default name is<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; created from the name of the executed data source.<br>-D –doc documentation&emsp;&emsp;&emsp;&nbsp; Set the documentation of the top level test suite.<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; Underscores in the documentation are converted to<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; spaces and it may also contain simple HTML formatting<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; (e.g. <em>bold</em> and <a href="http://url/" target="_blank" rel="noopener">http://url/</a>). </p></blockquote><p>最后使用 <code>pybot -Z 3 -t E:\autotest\test</code> 即可实现失败重跑功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本文通过修改RF源代码，增加命令pybot参数–retry N,以实现执行过程中，test级别的用例失败后自动再执行N次，或直到成功为止，生成的日志和报告文件中只记录最后一次执行结果。&lt;br&gt;
    
    </summary>
    
      <category term="自动化" scheme="http://yoursite.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="Robot Framework" scheme="http://yoursite.com/tags/Robot-Framework/"/>
    
  </entry>
  
  <entry>
    <title>markdown基本语法</title>
    <link href="http://yoursite.com/2018/01/05/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/05/markdown基本语法/</id>
    <published>2018-01-05T07:30:13.000Z</published>
    <updated>2018-06-25T11:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>&emsp;&emsp;Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。</p><blockquote><p>软件：MarkdownPad  </p></blockquote><h3 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h3><p>&emsp;&emsp;(1) 1级到6级标题，快捷键<kbd>Ctrl + i</kbd>  (i=1~6)，等效为 <span style="color:green">&gt;#..# 内容 #..#</span> 【注：#..#表示i个#号】</p><p>&emsp;&emsp;(2) #与文字之间加上空格，是markdown标准语法规则</p><p>&emsp;&emsp;(3) 在任意文字下一行加上任意个 = ，表示一级标题; 加 - 表示二级标题</p><h3 id="1-1-字体格式"><a href="#1-1-字体格式" class="headerlink" title="1.1 字体格式"></a>1.1 字体格式</h3><p>&emsp;&emsp;（1）加粗快捷键 <kbd>Ctrl + B</kbd>, 等效为 <span style="color:green">**<strong>粗体文本</strong>**</span></p><p>&emsp;&emsp;（2）斜体快捷键 <kbd>Ctrl + I</kbd>, 等效为 <span style="color:green">*<em>斜体文本</em>*</span></p><p>&emsp;&emsp;（3）删除线： <span style="color:green"> ~~<del>删除我</del>~~ </span></p><h3 id="1-2-分割线"><a href="#1-2-分割线" class="headerlink" title="1.2 分割线"></a>1.2 分割线</h3><p>&emsp;&emsp;快捷键 <kbd>Ctrl + R</kbd>,等效为 <span style="color:green">---,或者 ***</span>  </p><hr><h3 id="1-3-换行"><a href="#1-3-换行" class="headerlink" title="1.3 换行"></a>1.3 换行</h3><p>&emsp;&emsp;行末尾加上两个空格再回车</p><h3 id="1-4-脚注"><a href="#1-4-脚注" class="headerlink" title="1.4 脚注"></a>1.4 脚注</h3><p>&emsp;&emsp;这是一个脚注的例子<a href="这里是脚注">^1</a></p><pre><code>这是一个脚注的例子[^1][^1]: 这里是脚注</code></pre><hr><hr><h3 id="2-1-引用"><a href="#2-1-引用" class="headerlink" title="2.1 引用"></a>2.1 引用</h3><p>&emsp;&emsp;快捷键 <kbd>Ctrl + Q</kbd>,等效为 <span style="color:green">&gt; 内容</span></p><p>&emsp;&emsp;&emsp;<i>(注：多级引用可以使用多个&gt;&gt;)</i></p><blockquote><p>一级    &gt;</p><blockquote><p>二级   &gt;&gt;</p><blockquote><p>三级  &gt;&gt;&gt;</p></blockquote></blockquote></blockquote><h3 id="2-2-插入图片"><a href="#2-2-插入图片" class="headerlink" title="2.2 插入图片"></a>2.2 插入图片</h3><p>&emsp;&emsp;快捷键 <kbd>Ctrl + G</kbd>,等效为 <span style="color:green">![imgName](url)</span><br><img src="/upload/markdown_1.png" alt="imgName"></p><h3 id="2-3-插入链接"><a href="#2-3-插入链接" class="headerlink" title="2.3 插入链接"></a>2.3 插入链接</h3><p>&emsp;&emsp;语法为：<span style="color:green">[链接名称](url)</span></p><p>&emsp;&emsp;<a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></p><h3 id="2-4-序列"><a href="#2-4-序列" class="headerlink" title="2.4 序列"></a>2.4 序列</h3><p>&emsp;&emsp;（1）<strong>无序序列</strong> 快捷键 <kbd>Ctrl + U</kbd>    等效于 <span style="color:green">- 内容</span> 或者 <span style="color:green">+ 内容</span> 或者 <span style="color:green">* 内容</span></p><p>&emsp;&emsp;（2）<strong>有序序列</strong> 快捷键 <kbd>Ctrl + Shift + O</kbd>    等效于 <span style="color:green">1. 列表</span></p><h3 id="2-5-代码引用"><a href="#2-5-代码引用" class="headerlink" title="2.5 代码引用"></a>2.5 代码引用</h3><p>&emsp;&emsp;代码块：快捷键 <kbd>Ctrl + K</kbd>,等效为 <span style="color:green">4个以上的空格开头</span> 或者 <span style="color:green"> 3个反引号``` </span></p><p>&emsp;&emsp;可嵌入代码行：快捷键 <kbd>Ctrl + K</kbd>, <span style="color:green"> `代码` </span></p><hr><hr><h3 id="3-1-表格"><a href="#3-1-表格" class="headerlink" title="3.1 表格"></a>3.1 表格</h3><pre><code>|标题|标题|标题||:---|:---:|---:||居左测试文本|居中测试文本|居右测试文本||居左测试文本1|居中测试文本2|居右测试文本3||居左测试文本11|居中测试文本22|居右测试文本33||居左测试文本111|居中测试文本222|居右测试文本333|</code></pre><table><thead><tr><th style="text-align:left">标题</th><th style="text-align:center">标题</th><th style="text-align:right">标题</th></tr></thead><tbody><tr><td style="text-align:left">居左测试文本</td><td style="text-align:center">居中测试文本</td><td style="text-align:right">居右测试文本</td></tr><tr><td style="text-align:left">居左测试文本1</td><td style="text-align:center">居中测试文本2</td><td style="text-align:right">居右测试文本3</td></tr><tr><td style="text-align:left">居左测试文本11</td><td style="text-align:center">居中测试文本22</td><td style="text-align:right">居右测试文本33</td></tr><tr><td style="text-align:left">居左测试文本111</td><td style="text-align:center">居中测试文本222</td><td style="text-align:right">居右测试文本333</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;br&gt;&amp;emsp;&amp;emsp;Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的
      
    
    </summary>
    
      <category term="markdown" scheme="http://yoursite.com/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>M2Crypto使用</title>
    <link href="http://yoursite.com/2018/01/03/M2Crypto%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/03/M2Crypto使用/</id>
    <published>2018-01-03T05:46:55.000Z</published>
    <updated>2018-06-25T11:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>加解密数据、操作密钥、操作SSL协议普遍使用了OpenSSL。虽然还有其它的使用C/C++开发的加密处理库，但是Python环境下支持最好的使用最广泛的还是OpenSSL。 </p><p>据python.org官方网站，目前有三个库提供了OpenSSL的包装。 </p><ol><li>PyOpenSSL。这个库是比较早的，但是作者已经停止开发，并且只支持SSL功能，而没有提供加密、解密、X509等功能的包装。 </li><li>M2Crypto。完整支持OpenSSL。单元测试比较全面。在原有C语言API的基础上提供了Python的封装。 </li><li>ssl4py。与M2Crypto类似。但是完全使用C编写，与OpenSSL的API很类似。估计是用SWIG之类的工具生成的。据我本人看他的源代码，在调用EVP_CipherUpdate()函数的时候，输出大小没有计算正确。此错误会造成数据不正确，是一个比较严重的BUG。我估计应该还有其它的BUG存在，可能比较不成熟。 </li><li>ezPyCrypto。全名是Python Cryptography Toolkit。据水木网友josephpei说，这个很强大，有望进入官方CPython的标准库内。不过考虑到学习OpenSSL的API以后找工作比较好办，所以暂时不考虑。 </li></ol><p>综上所述，我在开发中使用M2Crypto。 </p><p>M2Crypto的API手册处于：<a href="http://www.heikkitoivonen.net/m2crypto/api/" target="_blank" rel="noopener">http://www.heikkitoivonen.net/m2crypto/api/</a> </p><p>目前，截止到2009年10月23日，官网上提供的M2Crypto for Python 2.6(win32)安装包是不正确的。因为它提供的0.19版本并没有兼容0.20。所以需要下载M2Crypto的源代码自行编译。以下是编译的步骤： </p><ol><li>下载安装mingw32:<a href="http://www.mingw.org" target="_blank" rel="noopener">http://www.mingw.org</a>. </li><li>下载安装 swig: <a href="http://www.swig.org。选择下载SWIG" target="_blank" rel="noopener">http://www.swig.org。选择下载SWIG</a> for python(win32)的版本。并且把swig的路径加入$PATH环境变量内。 </li><li>下载安装OpenSSL的Windows版本:<a href="http://www.slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">http://www.slproweb.com/products/Win32OpenSSL.html</a> </li><li>把OpenSSL的include文件夹复制到Python的include文件夹内。把OpenSSL的几个库文件(*.a)复制到mingw32的lib文件夹内。 </li><li>OpenSSL for windows的库文件与for Unix版本名字有些不大一样。需要把libeay32.dll.a改名liblibeay32.a，把libssl32.dll.a改名libssleay32.a。测试的版本是0.9.8h </li><li>运行setup.py build -c mingw32 bdist_wininst </li><li>一切顺利的话在dist文件夹下可以找到安装程序。 </li></ol><blockquote><p>M2Crypto主页提供了一处描述如何在windows平台下使用msvc编译openssl和M2Crypto的链接。经过试验，该方法不能在mingw32下成功。不过在一个用户评论上描述了mingw32下的方法，当时没仔细看，害我搞了半天没成功。 </p></blockquote><hr><p>经过我测试，编译后的M2Crypto虽然导入正常，但是一旦使用BIO进行文件操作，M2Crypto就会异常退出。并打印出No AppLink这样的错误信息。如果不使用BIO的话，好像又没啥问题。 </p><hr><p>下面是几个模块的大致介绍: </p><pre><code>M2Crypto.BIO 用于操作IO抽象类型。 M2Crypto.BN 用于操作大数 M2Crypto.DH 用于操作Diffie-Hellman key exchange protocol M2Crypto.EVP 高级的加密解密接口。与直接使用具体的加密算法不同。使用该接口，可以用相同的编程方式，调用不同的算法处理数据。它包含了对称加密算法与非对称加密算法的支持。 M2Crypto.EC 椭圆曲线非对称加密算法 M2Crypto.DSA DSA非对称加密算法 M2Crypto.RSA RSA非对称加密算法 M2Crypto.Rand 操作随机数 M2Crypto.SSL 操作SSL协议 M2Crypto.X509 操作X509 </code></pre><p>接下来，我们通过日常的编程任务来看看如何使用这些接口。 </p><h4 id="一、如何使用MD5、SHA1等消息散列算法。"><a href="#一、如何使用MD5、SHA1等消息散列算法。" class="headerlink" title="一、如何使用MD5、SHA1等消息散列算法。"></a>一、如何使用MD5、SHA1等消息散列算法。</h4><p>虽然OpenSSL提供了直接操作MD5、SHA1算法以及blowfish等各种对称加密算法的API，但是M2Crypto并没有将其包含进来。不过也好，各种算法都有各自的API，记起来麻烦。通过M2Crypto.EVP，我们仍然可以调用这些算法。下面是一个MD5的例子： </p><pre><code>def md5(s):  m=EVP.MessageDigest(&quot;md5&quot;) #在构造函数中传入算法的名字可以选择不同的消息散列算法  m.update(s)  return m.digest() #或者m.final() </code></pre><p>常用的散列算法还有sha1。使用方法与MD5类似，只是构造函数是： </p><pre><code>m=EVP.MessageDigest(&quot;sha1&quot;) </code></pre><h4 id="二、使用对称加密算法加密数据。"><a href="#二、使用对称加密算法加密数据。" class="headerlink" title="二、使用对称加密算法加密数据。"></a>二、使用对称加密算法加密数据。</h4><p>如前所述，我们需要使用EVP.Cipher这个比较抽象的API，而不是具体的算法。与EVP.MessageDigest()类似，EVP.Cipher主要提供四个函数： </p><pre><code>EVP.Cipher.__init__(self, alg, key, iv, op, key_as_bytes=0, d=&apos;md5&apos;, salt=&apos;12345678&apos;, i=1, padding=1) EVP.Cipher.update(self, data) EVP.Cipher.final() EVP.Cipher.set_padding(self, padding=1) </code></pre><p>下面是一段使用blowfish算法将明文”fish is here”加密成密文的函数代码： </p><pre><code>def blowfish_encrypt(s, password):          out=StringIO()          m=EVP.Cipher(&quot;bf_ecb&quot;, password, &quot;123456&quot;, 1, 1, &quot;sha1&quot;, &quot;saltsalt&quot;, 5, 1)          out.write(m.update(s))          out.write(m.final())          return out.getvalue() </code></pre><p>可以发现，最主要的是Cipher的构造函数: </p><pre><code>EVP.Cipher.__init__(self, alg, key, iv, op, key_as_bytes=0, d=&apos;md5&apos;, salt=&apos;12345678&apos;, i=1, padding=1) </code></pre><p>alg是指算法的名字，OpenSSL支持以下算法： </p><blockquote><p>des_cbc des_ecb des_cfb des_ofb<br>des_ede_cbc des_ede des_ede_ofb des_ede_cfb &emsp;&emsp;&emsp;&emsp;2DES算法<br>des_ede3_cbc des_ede3 des_ede3_ofb des_ede3_cfb &emsp;&emsp;3DES算法<br>desx_cbc<br>rc4<br>rc4_40 &emsp;&emsp; 密钥为40位的RC4算法<br>idea_cbc idea_ecb idea_cfb idea_ofb idea_cbc<br>rc4_cbc rc2_ecb rc2_cfb rc2_ofb<br>rc2_40_cbc rc2_64_cbc<br>bf_cbc bf_ecb bf_cfb bv_ofb &emsp;&emsp;&emsp;Blowfish算法<br>cast5_cbc cast5_ecb cast5_cfb cast5_ofb<br>rc5_32_12_16_cbc rc5_32_12_16_ecb rc5_32_12_16_cfb rc5_32_12_16_ofb </p></blockquote><p>key是加密所用的密钥。传入的是一段二进制数据，其长度是密钥的长度。不过，如果后面的参数key_as_bytes==1，那key是一个普通的任意长度的字符串，将与salt,i参数一起生成一个真正的密钥。比如说,假设算法alg的密钥长度是16，如果key_as_bytes==0，那么key应该传入”\xff\xff”两个字节的字符串。如果key_as_bytes==1，则可以传入类似于123456这样子的字符串。 </p><p>iv是指初始向量。与加密算法所使用的加密块的长度一致。有些加密算法并不使用iv这个变量。如果key_as_bytes==1。虽然OpenSSL的key_to_bytes()函数可以使用alt,key,salt,d,i四个参数生成真正的密钥和iv。但是M2Crypto内部并没有这样子做。而是直接使用原来的iv.如果iv的长度超过了加密算法所使用的加密块的长度，超过的长度会被截取。 </p><p>op用于指示解密或者加密操作。op==1表示加密操作;op==0表示解密操作。在做逆操作的时候，除了op不一样，其它参数应当保持一致。 </p><p>key_as_bytes参数如前所述。如果key_as_bytes==1。M2Crypto会使用alg, key, d, salt, i五个参数生成真正的密钥(注意，没有使用IV)。如果key_as_bytes==0，表示传入的是真正的密钥，d, salt, i三个参数就没有意义了。 </p><p>d是指生成密钥时所使用的散列算法。可以选择md5, sha1等。最好使用sha1，因为md5的破解看来只是时间问题了。  </p><p>salt是指生成密钥时所使用的盐。M2Crypto默认是123456。 </p><p>i是指生成密钥时所迭代的次数。迭代次数越多，使用暴力攻击就越不容易。 </p><p>padding是指填充加密块。大多数加密算法是以块为单位进行加密的。明文被切分为一个个固定大小的块。然后分别进行加密，得到与原来大小一致的加密块。但是明文的长度并不一定是加密块长度的整数倍。因此在处理最后一个块时需要进行填充。常用的填充算法是PKCS padding.如果没有允许padding并且最后一段明文不足以达到加密块的长度。EVP_EncryptFinal_ex()会返回一个错误。如果padding是允许的，但是密文最后并没有包含一个正确的填充块，EVP_DecryptoFinal()就会返回一个错误。padding默认是允许的。 </p><h4 id="三、-生成RSA密钥"><a href="#三、-生成RSA密钥" class="headerlink" title="三、 生成RSA密钥"></a>三、 生成RSA密钥</h4><p>DSA与RSA是比较常用的两种非对称加密算法。他们的使用方法与特性正如他们的名字，基本上大同小异。在OpenSSL内，使用与其它名字一样的结构体来表示这两个算法的密钥。在M2Crypto里，也是如此。只是在M2Crypto里DSA与RSA是两个类，带有签名、验证等方法。 </p><p>一般并不构造RSA与DSA类。而使用相应的工厂方法。比如生成RSA密钥： </p><pre><code>from M2Crypto import BIO, RSA def genrsa(): #这函数生成一个1024位的RSA密钥，将其转化成PEM格式返回      bio=BIO.MemoryBuffer()      rsa=RSA.gen_key(1024, 3, lambda *arg:None)      rsa.save_key_bio(bio, None)      return bio.read_all() </code></pre><p>RSA.gen_key()是一个工厂方法，它返回一个存储了新的RSA密钥的RSA.RSA()实例。它的方法签名是： </p><pre><code>gen_key(bits, e, callback=keygen_callback) </code></pre><p>bits参数是指RSA密钥的长度，1024以下的RSA密钥虽然还没有被破解，但是已经认为是不安全的了。作为CA使用的RSA密钥通常要求达到2048位以上。<br>e是RSA算法的public exponent。功能是什么？我也不大清楚，据OpenSSL的文档说，这个函数通常是三个奇数3,17,65537之一。<br>callback是一个回调函数。用于显示生成密钥的进度。具体请查阅OpenSSL的文档。 </p><p>这里是OpenSSL中对应的函数原型： </p><pre><code>#include &lt;openssl/rsa.h&gt; RSA *RSA_generate_key(int num, unsigned long e,void (*callback)(int,int,void *), void *cb_arg); </code></pre><h4 id="四、生成DSA密钥"><a href="#四、生成DSA密钥" class="headerlink" title="四、生成DSA密钥"></a>四、生成DSA密钥</h4><p>DSA算法相关的估计是另外的人开发的。API有些不大一样。它首先需要生成参数，然后才能生成密钥。以下是一段代码： </p><pre><code>from M2Crypto import BIO, DSA def gendsa(): #这函数生成一个1024位的DSA密钥，将其转化成PEM格式返回      bio=BIO.MemoryBuffer()      dsa = DSA.gen_params(1024, lambda *arg: None)      dsa.gen_key()      dsa.save_key_bio(bio,None)      return bio.read_all() </code></pre><p>可以发现生成DSA密钥时需要首先使用DSA.gen_params()生成DSA参数。gen_params()函数的第一个参数是DSA密钥的长度，第二个密钥与RSA.gen_key()的回调函数相同。DSA.gen_params()返回一个DSA类的实例。调用DSA.gen_key()方法生成密钥。其它的与RSA类似。 </p><h4 id="五、载入DSA密钥与RSA密钥"><a href="#五、载入DSA密钥与RSA密钥" class="headerlink" title="五、载入DSA密钥与RSA密钥"></a>五、载入DSA密钥与RSA密钥</h4><p>RSA:<br>返回RSA类型： </p><pre><code>load_key(file, callback=util.passphrase_callback) load_key_bio(bio, callback=util.passphrase_callback) load_key_string(string, callback=util.passphrase_callback) </code></pre><p>返回RSA_pub类型： </p><pre><code>load_pub_key(file) load_pub_key_bio(bio) </code></pre><p>DSA:<br>返回DSA类型： </p><pre><code>load_params(file, callback=util.passphrase_callback) load_params_bio(bio, callback=util.passphrase_callback) load_key(file, callback=util.passphrase_callback) load_key_bio(bio, callback=util.passphrase_callback) </code></pre><p>返回DSA_pub类型： </p><pre><code>load_pub_key(file, callback=util.passphrase_callback) load_pub_key_bio(bio, callback=util.passphrase_callback) </code></pre><p>这些函数大同小异。如果参数名字是file的话，代表的是一个文件名。如果参数名字是bio的话，代表的是一个BIO对像。BIO对象与Python的file对象类似都是用于表示一个可以读写的类似于文件的类型。BIO对象除了可以是一个普通的文件，还可以是一个ssh连接，还可以是一段内存(BIO.MemoryBuffer)。BIO.MemoryBuffer与Python的StringIO.StringIO类似。因为之前我们提到我编译的M2Crypto在进行文件IO的时候会异常退出，所以最好只使用BIO.MemoryBuffer。 </p><p>在本文里，提到密钥，是同时指公钥与私钥。<br>在OpenSSL及大多数软件里，因为公钥会被单独分发出去，所以公钥可以单独保存在公钥文件里。而密钥的所有者既然保存私钥，肯定也会同时保存公钥。故而私钥并不会单独保存到一个私钥文件里，而是和公钥一起保存在密钥文件里。 </p><h4 id="六、RSA类型的操作——使用RSA加密、解密、签名、认证；保存RSA密钥"><a href="#六、RSA类型的操作——使用RSA加密、解密、签名、认证；保存RSA密钥" class="headerlink" title="六、RSA类型的操作——使用RSA加密、解密、签名、认证；保存RSA密钥"></a>六、RSA类型的操作——使用RSA加密、解密、签名、认证；保存RSA密钥</h4><p>RSA类型封装了一些可以使用RSA密钥进行的操作。 </p><p>首先，可以使用len(rsa)获得RSA密钥的长度。单位是位，通常使用1024位以上的密钥才是安全的。 </p><p>public_encrypt(self, data, padding):<br>使用公钥进行加密。data是数据，padding参数是指是否填充加密块。具体的含义可以看看EVP.Cipher类的构造函数。data是一段普通的字符串，而padding的类型是布尔型。 </p><pre><code>def public_decrypt(self, data, padding): </code></pre><p>使用公钥进行解密。 </p><pre><code>def private_encrypt(self, data, padding): </code></pre><p>使用私钥进行加密。 </p><pre><code>def private_decrypt(self, data, padding): </code></pre><p>使用公钥进行加密。 </p><p>因为RSA是一种非对称加密算法。所以用私钥加密的数据，要用公钥才能解密。反之，用公钥加密的数据，要用私钥才能解密。通常在通信中，发送方使用接收方的公钥加密数据。<em>只有</em>接收方才有私钥能够解密数据。因为非对称加密算法的速度一般比对称加密算法慢，所以在一个连续的通信过程中，经常是发送方随机生成一个对称加密算法的密钥，然后使用非对称加密算法发送给接收方，以后所有的通信过程都是使用这个随机密钥。只要保证每隔一段时间就换一个密钥，这个通信过程就跟直接使用非对称加密算法一样安全了。类似于电子邮件这样的通信过程中，双方商量一个随机密钥的时间很长，所以还是乖乖直接用公钥加密的好。 </p><p>非对称算法还经常用于对数据进行签名。签名可以保证发送方不能否认自己发送的数据是自己的。比如，在一个电子商务交易中，客户下了一个订单，不能等工厂已经生产完了才否认这个订单是自己下的。签名最简单的办法当然是使用发送方的私钥进行加密。如果不使用发送方的公钥就不能解密数据。反之，也可以说，凡是可以使用发送方的公钥解密出数据，就说明数据是使用发送方的私钥加密的。在现实生活中，人们一般是使用SHA1之类的散列算法算出数据的散列值，然后再用私钥加密这个散列值。接收方接收到数据与散列值之后，同样使用SHA1算法算出数据的散列值，与使用公钥解密出来的散列值作对比。如果是一样的，说明数据正确。如果不一样，或者是在传输过程中被更改了，或者根本不是发送方所发送的。 </p><p>RSA算法提供了两种签名的方式，其分别可能是不同的国际标准。我还不是很清楚。 </p><pre><code>sign_rsassa_pss(self, digest, algo=&apos;sha1&apos;, salt_length=20); verify_rsassa_pss(self, data, signature, algo=&apos;sha1&apos;, salt_length=20) </code></pre><p>这组API与下面两个函数类似。看起来差不多的样子，不过我没有进行过测试。实际上OpenSSL中并没有sign_rsassa_pss()这样函数。它实际上是分为两个步骤： </p><pre><code>RSA_padding_add_PKCS1_PSS()和 RSA_private_encrypt() </code></pre><p>而verify_rsassa_pss()函数则分为 </p><pre><code>RSA_public_decrypt()与 RSA_verify_PKCS1_PSS() 两个步骤 sign(self, digest, algo=&apos;sha1&apos;): verify(self, data, signature, algo=&apos;sha1&apos;) </code></pre><p>这组API对应于OpenSSL中的RSA_sign()与RSA_verify()函数。分别是签名与验证。虽然sign()方法接收散列算法的名字作为名字，但实际上digest参数应该是已经计算出的散列值。以下是对一段数据进行签名的代码： </p><p>发送方对数据进行签名 </p><pre><code>from M2Crypto import * m=EVP.EVP.MessageDigest(&quot;sha1&quot;) #先计算散列值 m.update(&quot;fish is here&quot;) digest=m.final() key_str=file(&quot;fish_private.pem&quot;,&quot;rb&quot;).read() #读入私钥 key=RSA.load_key_string(key_str, util.no_passphrase_callback) result=key.sign(digest, &quot;sha1&quot;) #签名后得到的数据。与原始数据一起发送出去。 </code></pre><p>接收方验证数据 </p><pre><code>from M2Crypto import * m=EVP.EVP.MessageDigest(&quot;sha1&quot;) #先计算散列值 m.update(&quot;fish is here&quot;) digest=m.final() #先计算散列值 cert_str=file(&quot;fish_public.pem&quot;, &quot;rb&quot;).read() #读入公钥 mb=BIO.MemoryBuffer(cert_str) cert=RSA.load_pub_key_bio(mb) #RSA模式没有load_pub_key_string()方法，需自行使用MemoryBuffer cert.verify(digest, result, &quot;sha1&quot;) </code></pre><h4 id="七、一个小型的CA，电子证书。"><a href="#七、一个小型的CA，电子证书。" class="headerlink" title="七、一个小型的CA，电子证书。"></a>七、一个小型的CA，电子证书。</h4><p>说到CA，不得不说到PKI认证体系。PKI体系是一个概念性的认证系统。它的基本原理是，通信系统内所有节点都承认一个权威的机构，称为CA。所有参与通信的节点都有一个电子证书，由该节点的公钥和身份认证信息组成。CA核查这个电子证书的身份信息是否正确。如果正确的话，就使用CA的秘钥进行签名。这样，所有的通信节点就可以使用电子证书内包含的身份信息而不必亲自核查了。 </p><p>所有通信节点都持有CA的电子证书。CA的电子证书是CA自己签名的。在PKI系统运行之前，人们会事先设置好CA证书。 </p><p>通信节点生成电子证书的过程是：<br>1、通信节点生成RSA或者DSA等非对称加密算法的密钥。<br>2、通信节点生成电子证书请求文件(X509_Request)。其中包含通信节点的身份信息、公钥，并且用通信节点的私钥签名。<br>3、CA读取电子证书请求文件。核查身份信息是否正确。如果身份信息正确就生成通信节点的电子证书。其中包含CA的身份信息、通信节点的身份信息、通信节点的公钥、电子证书的起始有效时间，电子证书的结束有效时间。通常还会记录这是CA所颁发的第几个证书。</p><p>生成非对称加密算法的密钥在之前已经有提到过了。接下来是如何生成证书请求文件的代码： </p><pre><code>from M2Crypto import * #首先载入密钥文件。此文件同时保存了通信节点的私钥与公钥。 #这里并不像之前直接使用 pkey_str=file(&quot;fish_private.pem&quot;, &quot;rb&quot;).read() pkey=EVP.load_key_string(pkey_str, util.no_passphrase_callback) req=X509.Request() req.set_pubkey(pkey) #包含公钥 #req.set_version(1) name=X509.X509_Name() #身份信息不是简单的字符串。而是X509_Name对象。 name.CN=&quot;Goldfish&quot; #CN是Common Name的意思。如果是一个网站的电子证书，就要写成网站的域名 name.OU=&quot;Manager&quot; #Organization Unit，通常是指部门吧，组织内单元 name.O=&quot;ZieglerT&quot; #Organization。通常是指公司 name.ST=&quot;Fujian&quot; #State or Province。州或者省 name.L=&quot;Quanzhou&quot; #Locale。 name.C=&quot;CN&quot; #国家。不能直接写国家名字，比如China之类的，而应该是国家代码。CN代表中国。US代表美国，JP代表日本 req.set_subject(name) #包含通信节点的身份信息 req.sign(pkey, &quot;sha1&quot;) #使用通信节点的密钥进行签名 file(&quot;fish_req.pem&quot;, &quot;wb&quot;).write(req.as_pem()) #写入到文件 </code></pre><p>可以发现，如果简化那些设置身份信息的代码，实际上就是三步：包含公钥、包含身份信息、签名。 </p><p>接下来，我们看看CA是如何给一个通信节点发放证书的。 </p><pre><code>from M2Crypto import * import time #首先读取证书请求文件。 req_str=file(&quot;fish_req.pem&quot;, &quot;rb&quot;).read() req=X509.load_request_string(req_str) #返回一个X509.Request类型代表证书请求文件 print req.verify(req.get_pubkey()) #首先验证一下，是不是真的是使用它本身的私钥签名的。如果是，返回非0值。如果不是，说明这是一个非法的证书请求文件。 #接下来载入CA的电子证书。与CA的密钥不一样，CA的电子证书包含了CA的身份信息。CA的电子证书会分发给各个通信节点。 ca_str=file(&quot;ca.pem&quot;, &quot;rb&quot;).read() ca=X509.load_cert_string(ca_str) #print ca.check_ca() #可以使用check_ca()方法判断这个证书文件是不是CA。本质是判断它是不是自签名。如果是的话，就返回非0值。如果不是的话就返回0。 #接下来载入CA的密钥 cakey_str=file(&quot;cakey.pem&quot;, &quot;rb&quot;).read() cakey=EVP.load_key_string(cakey_str, lambda *args:&quot;1234&quot;) #一般CA的密钥要加密保存。回调函数返回密码 #接下来开始生成电子证书 cert=X509.X509() #首先，设定开始生效时间与结束生效时间 t = long(time.time()) + time.timezone #当前时间，单位是秒 now = ASN1.ASN1_UTCTIME() #开始生效时间。证书的时间类型不是普通的Python datetime类型。 now.set_time(t) nowPlusYear = ASN1.ASN1_UTCTIME() #结束生效时间 nowPlusYear.set_time(t + 60 * 60 * 24 * 365) #一年以后。 cert.set_not_before(now) cert.set_not_after(nowPlusYear) cert.set_subject(req.get_subject()) #把证书请求附带的身份信息复制过来 cert.set_issuer(ca.get_subject()) #设置颁发者的身份信息，把CA电子证书内身份信息复制过来 cert.set_serial_number(2) #序列号是指，CA颁发的第几个电子证书文件 cert.set_pubkey(req.get_pubkey()) #把证书请求内的公钥复制过来 cert.sign(cakey, &quot;sha1&quot;) #使用CA的秘钥进行签名。 file(&quot;fishcert2.pem&quot;, &quot;wb&quot;).write(cert.as_pem()) #保存文件。 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;加解密数据、操作密钥、操作SSL协议普遍使用了OpenSSL。虽然还有其它的使用C/C++开发的加密处理库，但是Python环境下支持最好的使用最广泛的还是OpenSSL。 &lt;/p&gt;
&lt;p&gt;据python.org官方网站，目前有三个库提供了OpenSSL的包装。 &lt;/p&gt;

      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="crypt" scheme="http://yoursite.com/tags/crypt/"/>
    
      <category term="rsa" scheme="http://yoursite.com/tags/rsa/"/>
    
  </entry>
  
</feed>
